"use client";
import { jsx as _jsx, jsxs as _jsxs } from "@emotion/react/jsx-runtime";
/**
 * A very small context provider for the user object - it takes the user object from the cookie and provides it to the app.
 */
import React, { startTransition, useCallback, useEffect, useRef, useState, } from "react";
import { resolveAuthConfig, } from "../../nextjs/config.js";
import { resolveCallbackUrl } from "../../nextjs/utils.js";
import { ConfidentialClientPKCEConsumer } from "../../services/PKCE.js";
import { UserProvider } from "../../shared/providers/UserProvider.js";
import { useUserCookie } from "../../nextjs/hooks/useUserCookie.js";
import { CivicAuthConfigProvider } from "../../shared/providers/CivicAuthConfigContext.js";
import { SessionProvider } from "../../shared/providers/SessionProvider.js";
import { IframeProvider } from "../../shared/providers/IframeProvider.js";
import { TokenProvider } from "../../shared/providers/TokenProvider.js";
import { useSignIn } from "../../shared/hooks/useSignIn.js";
import { useCivicAuthConfig } from "../../shared/hooks/useCivicAuthConfig.js";
import { IFrameAndLoading } from "../../shared/components/IFrameAndLoading.js";
import { BlockDisplay } from "../../shared/components/BlockDisplay.js";
import { LoadingIcon } from "../../shared/components/LoadingIcon.js";
import { useIframe } from "../../shared/hooks/useIframe.js";
import { useIsInIframe } from "../../shared/hooks/useIsInIframe.js";
import { AuthStatus } from "../../types.js";
import { useRefresh } from "../../nextjs/hooks/useRefresh.js";
import { useCurrentUrl, useSession } from "../../shared/hooks/index.js";
import { BrowserCookieStorage } from "../../shared/index.js";
import { getIframeRef } from "../../shared/lib/iframeUtils.js";
import { AuthStatusProvider } from "../../shared/providers/AuthStatusContext.js";
import { useIsClient } from "usehooks-ts";
import { useRouter } from "next/navigation.js";
const CivicNextAuthTokenProviderInternal = ({ children, displayMode = "iframe", user, fetchUser, ...props }) => {
    const { iframeMode, resolvedConfig } = props;
    const { iframeRef, setIframeIsVisible, isIframeMounted, setIframeMounted } = useIframe();
    const civicAuthConfig = useCivicAuthConfig();
    const { challengeUrl } = resolvedConfig;
    const pkceConsumer = new ConfidentialClientPKCEConsumer(challengeUrl, resolvedConfig.basePath);
    const { data: session } = useSession();
    const currentUrl = useCurrentUrl();
    useEffect(() => {
        if (session?.authenticated) {
            setIframeMounted(false);
            // the session is authenticated, so don't show the login iframe
            setIframeIsVisible(false);
            return;
        }
    }, [session?.authenticated, setIframeIsVisible, setIframeMounted]);
    const postSignOut = useCallback(async () => {
        // user is signed out, manually update the user from cookies to not wait for polling
        fetchUser();
        await props?.onSignOut?.();
    }, [fetchUser, props]);
    const { signIn, startSignIn, signOut, authStatus } = useSignIn({
        postSignOut,
        pkceConsumer,
        displayMode,
    });
    const { error: refreshError } = useRefresh();
    useEffect(() => {
        const ref = getIframeRef(iframeRef?.current, true);
        if (isIframeMounted &&
            civicAuthConfig &&
            !session?.authenticated &&
            ref &&
            authStatus === AuthStatus.UNAUTHENTICATED &&
            displayMode === "iframe" &&
            !currentUrl?.includes("code=")) {
            startSignIn();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isIframeMounted,
        currentUrl,
        iframeMode,
        iframeRef,
        civicAuthConfig,
        session?.authenticated,
        authStatus,
        startSignIn,
        displayMode,
    ]);
    useEffect(() => {
        if (refreshError) {
            console.error("Error refreshing token, signing out...", refreshError);
            signOut();
        }
    }, [refreshError, signOut]);
    // if the SDK loads in an iframe, we show the loading spinner as the iframe
    // will be waiting to be minimized
    const isInIframe = useIsInIframe();
    // we need this as server-side rendering will not have a window object
    // and will throw an error if we try to access it
    const isClient = useIsClient();
    return !isClient ? null : (_jsx(TokenProvider, { children: _jsxs(UserProvider, { storage: new BrowserCookieStorage(), user: user, signOut: signOut, signIn: signIn, displayMode: displayMode, authStatus: authStatus, children: [_jsx(IFrameAndLoading, { error: null, isLoading: isInIframe }), isInIframe && (_jsx(BlockDisplay, { children: _jsx(LoadingIcon, {}) })), children] }) }));
};
const CivicNextAuthProviderInternal = ({ children, ...props }) => {
    const { user, idToken, fetchUser, isLoading, userChanged } = useUserCookie();
    const hasRunRef = useRef(false);
    const router = useRouter();
    // if there are any changes in the user object, we need to refresh the page
    // to handle both login and logout cases. We use a 'hasRun' ref to prevent
    // the refresh from running multiple times in a row
    useEffect(() => {
        if (userChanged) {
            if (!hasRunRef.current) {
                hasRunRef.current = true;
                startTransition(() => {
                    router.refresh();
                });
            }
        }
        else {
            hasRunRef.current = false;
        }
    }, [userChanged, router]);
    const session = {
        authenticated: !!user,
        idToken,
    };
    return (_jsx(SessionProvider, { data: session, isLoading: isLoading, children: _jsx(CivicNextAuthTokenProviderInternal, { ...props, user: user, idToken: idToken, fetchUser: fetchUser, isLoading: isLoading, children: children }) }));
};
const CivicNextAuthProvider = ({ children, ...props }) => {
    const resolvedConfig = resolveAuthConfig();
    const { clientId, oauthServer, callbackUrl, challengeUrl, logoutUrl, refreshUrl, logoutCallbackUrl, } = resolvedConfig;
    const [redirectUrl, setRedirectUrl] = useState("");
    useEffect(() => {
        if (typeof globalThis.window !== "undefined") {
            const appUrl = globalThis.window.location.origin;
            setRedirectUrl(resolveCallbackUrl(resolvedConfig, appUrl));
        }
    }, [callbackUrl, resolvedConfig]);
    return (_jsx(CivicAuthConfigProvider, { oauthServer: oauthServer, clientId: clientId, redirectUrl: redirectUrl, logoutRedirectUrl: logoutCallbackUrl, nonce: props?.nonce, challengeUrl: challengeUrl, refreshUrl: refreshUrl, logoutUrl: logoutUrl, logoutCallbackUrl: logoutCallbackUrl, children: _jsx(AuthStatusProvider, { children: _jsx(IframeProvider, { iframeMode: props.iframeMode, children: _jsx(CivicNextAuthProviderInternal, { ...props, resolvedConfig: resolvedConfig, children: children }) }) }) }));
};
export { CivicNextAuthProvider };
//# sourceMappingURL=NextAuthProvider.js.map