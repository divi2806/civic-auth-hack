"use client";
import { useCallback, useEffect, useRef, useState } from "react";
import { OAuthTokenTypes, UserStorage } from "../../shared/lib/types.js";
import { objectsAreEqual } from "../../lib/obj.js";
import { BrowserCookieStorage } from "../../shared/index.js";
import { useIsClient } from "usehooks-ts";
const browserCookieStorage = new BrowserCookieStorage();
const getUserAndTokenFromCookie = () => {
    const userCookie = browserCookieStorage.getSync(UserStorage.USER);
    const idTokenCookie = browserCookieStorage.getSync(OAuthTokenTypes.ID_TOKEN);
    return {
        [UserStorage.USER]: userCookie ? JSON.parse(userCookie) : undefined,
        [OAuthTokenTypes.ID_TOKEN]: idTokenCookie || undefined,
    };
};
export const useUserCookie = () => {
    // need to make sure this is only run on the client
    // because it uses cookies that expect a document object to be present to read from
    const isClient = useIsClient();
    const response = (isClient && getUserAndTokenFromCookie()) || {};
    // initialise user and token from cookies so that we don't
    // have to wait for the first fetch to expose these values
    const userData = response[UserStorage.USER];
    const tokenData = response[OAuthTokenTypes.ID_TOKEN];
    // we need both a ref and state for the user and token
    // because the ref is used to compare the previous value
    // to the new value to see if it has changed
    // and the state is used to trigger a re-render
    // when the value changes
    const userRef = useRef(userData);
    const tokenRef = useRef(tokenData);
    const [user, setUser] = useState(userData);
    const [idToken, setToken] = useState(tokenData);
    const [userChanged, setUserChanged] = useState(false);
    const [initialFetchComplete, setInitialFetchComplete] = useState(!!userData);
    const fetchUser = useCallback((abortController) => {
        if (abortController?.signal.aborted) {
            setInitialFetchComplete(true);
            return;
        }
        const response = getUserAndTokenFromCookie() || {};
        const userData = response[UserStorage.USER];
        const tokenData = response[OAuthTokenTypes.ID_TOKEN];
        if (abortController?.signal.aborted) {
            setInitialFetchComplete(true);
            return;
        }
        // we use objectsAreEqual here comparing the object references could trigger
        // unnecessary re-renders if the object is the same but a new reference is created
        if (!objectsAreEqual(userData, userRef.current)) {
            userRef.current = userData || null;
            setUser(userData || null);
            setUserChanged(true);
        }
        if (tokenData !== tokenRef.current) {
            tokenRef.current = tokenData;
            setToken(tokenData);
        }
        setInitialFetchComplete(true);
    }, []);
    /**
     * Set up a listener for when the user cookies change which will be triggered
     * by server-side during token exchange. We are able to receive these updates as the auth
     * calls will be running in the iframe and the cookies will be set in the parent window.
     */
    useEffect(() => {
        let abortController = new AbortController();
        const cookieListener = () => {
            // pass an abort controller to fetchUser to cancel any in-flight requests
            // that might have been triggered before re-render
            abortController = new AbortController();
            fetchUser(abortController);
        };
        document.addEventListener("visibilitychange", cookieListener);
        window.addEventListener("storage", cookieListener);
        window.addEventListener("focus", cookieListener);
        // set the user and token ref from cookies again as the component has now mounted
        // so cookies might be available that weren't there at initialisation above
        const response = getUserAndTokenFromCookie() || {};
        const userData = response[UserStorage.USER];
        const tokenData = response[OAuthTokenTypes.ID_TOKEN];
        userRef.current = userData;
        tokenRef.current = tokenData;
        setUser(userData);
        setToken(tokenData);
        fetchUser(abortController);
        // poll for changes to the cookies every 2 seconds
        // this is required as react doesn't have a built-in hook that will change on cookie changes
        const intervalId = setInterval(cookieListener, 2000);
        return () => {
            abortController.abort();
            document.removeEventListener("visibilitychange", cookieListener);
            window.removeEventListener("storage", cookieListener);
            window.removeEventListener("focus", cookieListener);
            clearInterval(intervalId);
        };
    }, [fetchUser]);
    return {
        user,
        idToken,
        userChanged,
        fetchUser,
        isLoading: !initialFetchComplete,
    };
};
//# sourceMappingURL=useUserCookie.js.map