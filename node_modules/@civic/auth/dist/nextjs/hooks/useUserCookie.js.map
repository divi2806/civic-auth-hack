{"version":3,"file":"useUserCookie.js","sourceRoot":"","sources":["../../../src/nextjs/hooks/useUserCookie.ts"],"names":[],"mappings":"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","sourcesContent":["\"use client\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { EmptyObject, User } from \"@/types.js\";\nimport { OAuthTokenTypes, UserStorage } from \"@/shared/lib/types.js\";\nimport { objectsAreEqual } from \"@/lib/obj.js\";\nimport { BrowserCookieStorage } from \"@/shared/index.js\";\nimport { useIsClient } from \"usehooks-ts\";\n\ntype UserAndTokenFromCookie = {\n  [UserStorage.USER]: User | undefined;\n  [OAuthTokenTypes.ID_TOKEN]: string | undefined;\n};\nconst browserCookieStorage = new BrowserCookieStorage();\nconst getUserAndTokenFromCookie = (): UserAndTokenFromCookie => {\n  const userCookie = browserCookieStorage.getSync(\n    UserStorage.USER,\n  ) as unknown as string | null;\n  const idTokenCookie = browserCookieStorage.getSync(\n    OAuthTokenTypes.ID_TOKEN,\n  ) as unknown as string | null;\n  return {\n    [UserStorage.USER]: userCookie ? JSON.parse(userCookie) : undefined,\n    [OAuthTokenTypes.ID_TOKEN]: idTokenCookie || undefined,\n  };\n};\n\nexport const useUserCookie = <T extends EmptyObject>() => {\n  // need to make sure this is only run on the client\n  // because it uses cookies that expect a document object to be present to read from\n  const isClient = useIsClient();\n  const response =\n    (isClient && getUserAndTokenFromCookie()) || ({} as UserAndTokenFromCookie);\n  // initialise user and token from cookies so that we don't\n  // have to wait for the first fetch to expose these values\n  const userData = response[UserStorage.USER] as User<T>;\n  const tokenData = response[OAuthTokenTypes.ID_TOKEN];\n\n  // we need both a ref and state for the user and token\n  // because the ref is used to compare the previous value\n  // to the new value to see if it has changed\n  // and the state is used to trigger a re-render\n  // when the value changes\n  const userRef = useRef(userData);\n  const tokenRef = useRef(tokenData);\n  const [user, setUser] = useState<User<T> | null>(userData);\n  const [idToken, setToken] = useState<string | undefined>(tokenData);\n  const [userChanged, setUserChanged] = useState<boolean>(false);\n  const [initialFetchComplete, setInitialFetchComplete] = useState(!!userData);\n\n  const fetchUser = useCallback((abortController?: AbortController) => {\n    if (abortController?.signal.aborted) {\n      setInitialFetchComplete(true);\n      return;\n    }\n\n    const response = getUserAndTokenFromCookie() || {};\n    const userData = response[UserStorage.USER] as User<T>;\n    const tokenData = response[OAuthTokenTypes.ID_TOKEN];\n\n    if (abortController?.signal.aborted) {\n      setInitialFetchComplete(true);\n      return;\n    }\n\n    // we use objectsAreEqual here comparing the object references could trigger\n    // unnecessary re-renders if the object is the same but a new reference is created\n    if (!objectsAreEqual(userData, userRef.current)) {\n      userRef.current = userData || null;\n      setUser(userData || null);\n      setUserChanged(true);\n    }\n    if (tokenData !== tokenRef.current) {\n      tokenRef.current = tokenData;\n      setToken(tokenData);\n    }\n    setInitialFetchComplete(true);\n  }, []);\n\n  /**\n   * Set up a listener for when the user cookies change which will be triggered\n   * by server-side during token exchange. We are able to receive these updates as the auth\n   * calls will be running in the iframe and the cookies will be set in the parent window.\n   */\n  useEffect(() => {\n    let abortController = new AbortController();\n    const cookieListener = () => {\n      // pass an abort controller to fetchUser to cancel any in-flight requests\n      // that might have been triggered before re-render\n      abortController = new AbortController();\n      fetchUser(abortController);\n    };\n\n    document.addEventListener(\"visibilitychange\", cookieListener);\n    window.addEventListener(\"storage\", cookieListener);\n    window.addEventListener(\"focus\", cookieListener);\n\n    // set the user and token ref from cookies again as the component has now mounted\n    // so cookies might be available that weren't there at initialisation above\n    const response =\n      getUserAndTokenFromCookie() || ({} as UserAndTokenFromCookie);\n    const userData = response[UserStorage.USER] as User<T>;\n    const tokenData = response[OAuthTokenTypes.ID_TOKEN];\n    userRef.current = userData;\n    tokenRef.current = tokenData;\n    setUser(userData);\n    setToken(tokenData);\n    fetchUser(abortController);\n\n    // poll for changes to the cookies every 2 seconds\n    // this is required as react doesn't have a built-in hook that will change on cookie changes\n    const intervalId = setInterval(cookieListener, 2000);\n\n    return () => {\n      abortController.abort();\n      document.removeEventListener(\"visibilitychange\", cookieListener);\n      window.removeEventListener(\"storage\", cookieListener);\n      window.removeEventListener(\"focus\", cookieListener);\n      clearInterval(intervalId);\n    };\n  }, [fetchUser]);\n\n  return {\n    user,\n    idToken,\n    userChanged,\n    fetchUser,\n    isLoading: !initialFetchComplete,\n  };\n};\n"]}