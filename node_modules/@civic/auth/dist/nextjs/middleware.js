import { NextResponse } from "next/server.js";
import picomatch from "picomatch";
import { resolveAuthConfig } from "../nextjs/config.js";
import { loggers } from "../lib/logger.js";
import { ServerAuthenticationResolver } from "../server/ServerAuthenticationResolver.js";
const logger = loggers.nextjs.middleware;
/**
 * CookieStorage implementation for NextJS middleware context that works with NextRequest
 */
class NextjsReadOnlyRequestCookieStorage {
    request;
    constructor(request) {
        this.request = request;
    }
    async get(key) {
        return this.request.cookies.get(key)?.value || null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async set(key, value) {
        // In middleware, we can only set cookies via response objects
        // This method can't be used directly in middleware
        logger.error("Cannot set cookies directly in middleware");
        throw new Error("Cannot set cookies directly in middleware");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async delete(key) {
        // In middleware, we can only delete cookies via response objects
        // This method can't be used directly in middleware
        logger.error("Cannot delete cookies directly in middleware");
        throw new Error("Cannot delete cookies directly in middleware");
    }
}
// Matches globs:
// Examples:
// /user
// /user/*
// /user/**/info
const matchGlob = (pathname, globPattern) => {
    const matches = picomatch(globPattern);
    return matches(pathname);
};
// Matches globs:
// Examples:
// /user
// /user/*
// /user/**/info
const matchesGlobs = (pathname, patterns) => patterns.some((pattern) => {
    if (!pattern)
        return false;
    return matchGlob(pathname, pattern);
});
/**
 * use a ServerAuthenticationResolver to validate the existing session
 * using NextJS cookie storage
 * @param authConfigWithDefaults
 * @param request NextRequest object from middleware
 * @returns {Promise<SessionData>}
 */
export const validateAuthTokensIfPresent = async (authConfigWithDefaults, request) => {
    try {
        // TODO: evaluate a more performant way to validate tokens
        // than having to call and verify the JWT tokens on every request
        const storage = new NextjsReadOnlyRequestCookieStorage(request);
        const authSessionService = await ServerAuthenticationResolver.build({
            ...authConfigWithDefaults,
            redirectUrl: authConfigWithDefaults.callbackUrl,
        }, storage);
        // validate the existing session but don't auto-refresh as we can't set cookies in middleware
        const existingSession = await authSessionService.validateExistingSession(false);
        return existingSession;
    }
    catch (error) {
        logger.error("Error validating tokens", error);
        return { authenticated: false };
    }
};
// internal - used by all exported functions
const applyAuth = async (authConfig, request) => {
    const authConfigWithDefaults = resolveAuthConfig(authConfig);
    // Check for any valid auth token
    const session = await validateAuthTokensIfPresent(authConfigWithDefaults, request);
    // skip auth check for any civic auth urls
    if ([
        authConfigWithDefaults.loginUrl,
        authConfigWithDefaults.callbackUrl,
        authConfigWithDefaults.challengeUrl,
        authConfigWithDefaults.logoutCallbackUrl,
        authConfigWithDefaults.logoutUrl,
    ].includes(request.nextUrl.pathname) &&
        request.method === "GET") {
        logger.debug("→ Skipping auth check - this is the login URL");
        return undefined;
    }
    if (!matchesGlobs(request.nextUrl.pathname, authConfigWithDefaults.include)) {
        logger.debug("→ Skipping auth check - path not in include patterns");
        return undefined;
    }
    if (matchesGlobs(request.nextUrl.pathname, authConfigWithDefaults.exclude)) {
        logger.debug("→ Skipping auth check - path in exclude patterns");
        return undefined;
    }
    // Check for either token type
    if (!session.authenticated) {
        if (session.refreshToken) {
            const refreshUrl = new URL(authConfigWithDefaults.refreshUrl, request.nextUrl.origin);
            // set targetUrl to the original request URL without search params
            // to avoid redirect loops
            refreshUrl.searchParams.set("targetUrl", request.nextUrl.origin + request.nextUrl.pathname);
            const redirectUrl = `${refreshUrl.toString()}`;
            logger.debug(`→ Refresh token found - redirecting to "${redirectUrl}"`);
            return NextResponse.redirect(redirectUrl);
        }
        const loginUrl = new URL(authConfigWithDefaults.loginUrl, request.nextUrl.origin);
        const redirectUrl = `${loginUrl.toString()}`;
        logger.debug(`→ No valid token found - redirecting to "${redirectUrl}"`);
        return NextResponse.redirect(redirectUrl);
    }
    logger.debug("→ Auth check passed");
    return undefined;
};
/**
 *
 * Use this when auth is the only middleware you need.
 * Usage:
 *
 * export default authMiddleware({ loginUrl = '/login' }); // or just authMiddleware();
 *
 */
export const authMiddleware = (authConfig = {}) => async (request) => {
    const response = await applyAuth(authConfig, request);
    if (response)
        return response;
    // NextJS doesn't do middleware chaining yet, so this does not mean
    // "call the next middleware" - it means "continue to the route handler"
    return NextResponse.next();
};
/**
 * Usage:
 *
 * export default withAuth(async (request) => {
 *    logger.debug('my middleware');
 *    return NextResponse.next();
 *  })
 */
// use this when you have your own middleware to chain
export function withAuth(middleware) {
    return auth()(middleware);
}
/**
 * Use this when you want to configure the middleware here (an alternative is to do it in the next.config file)
 *
 * Usage:
 *
 * export default auth(authConfig: AuthConfig ) => {
 *    logger.debug('my middleware');
 *    return NextResponse.next();
 *  })
 *
 */
export function auth(authConfig = {}) {
    return (middleware) => {
        return async (request) => {
            const response = await applyAuth(authConfig, request);
            if (response)
                return response;
            return middleware(request);
        };
    };
}
//# sourceMappingURL=middleware.js.map