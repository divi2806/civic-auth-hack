import {} from "../types.js";
import { getUser as getUserFromShared, getTokens as getTokensFromShared, } from "../shared/lib/session.js";
import { clearTokens as clearTokensUtil } from "../shared/lib/util.js";
import { resolveOAuthAccessCode } from "../server/login.js";
import { buildLoginUrl } from "../server/login.js";
import { buildLogoutRedirectUrl } from "../server/logout.js";
import { refreshTokens } from "../server/refresh.js";
import { ServerAuthenticationResolver } from "../server/ServerAuthenticationResolver.js";
import { DEFAULT_AUTH_SERVER } from "../constants.js";
/**
 * CivicAuth is the main entry point for server-side authentication operations.
 * It provides a unified interface to all the authentication functions.
 */
export class CivicAuth {
    storage;
    authConfig;
    _authResolver = null;
    constructor(storage, authConfig) {
        this.storage = storage;
        this.authConfig = authConfig;
    }
    get oauthServer() {
        return this.authConfig.oauthServer || DEFAULT_AUTH_SERVER;
    }
    async getAuthResolver() {
        if (this._authResolver) {
            return Promise.resolve(this._authResolver);
        }
        this._authResolver = await ServerAuthenticationResolver.build({
            ...this.authConfig,
            oauthServer: this.oauthServer,
        }, this.storage);
        return this._authResolver;
    }
    /**
     * Gets the authenticated user with token validation
     * @returns The user object if authenticated, null otherwise
     */
    async getUser() {
        const resolver = await this.getAuthResolver();
        try {
            // Validate the session before returning the user
            const session = await resolver.validateExistingSession();
            if (!session?.authenticated) {
                return null;
            }
            // If session is valid, use the shared implementation to get the user
            return getUserFromShared(this.storage);
        }
        catch (error) {
            console.error("Token validation failed during getUser", error);
            return null;
        }
    }
    /**
     * Gets the authentication tokens with token validation
     * @returns The tokens if authenticated, null otherwise
     */
    async getTokens() {
        const resolver = await this.getAuthResolver();
        try {
            // Validate the session before returning the tokens
            const session = await resolver.validateExistingSession();
            if (!session?.authenticated) {
                return null;
            }
            // If session is valid, use the shared implementation to get the tokens
            return getTokensFromShared(this.storage);
        }
        catch (error) {
            console.error("Token validation failed during getTokens", error);
            return null;
        }
    }
    /**
     * Resolve an OAuth access code to a set of OIDC tokens
     * @param code The access code from the query parameter
     * @param state The OAuth state parameter
     * @returns OIDC tokens
     */
    async resolveOAuthAccessCode(code, state) {
        return resolveOAuthAccessCode(code, state, this.storage, this.authConfig);
    }
    /**
     * Check if the user is currently logged in
     * @returns true if logged in, false otherwise
     */
    async isLoggedIn() {
        const resolver = await this.getAuthResolver();
        const session = await resolver.validateExistingSession();
        return session?.authenticated ?? false;
    }
    /**
     * Build a login URL to redirect the user to
     * @param options Additional options for building the login URL
     * @returns The login URL
     */
    async buildLoginUrl(options) {
        return buildLoginUrl({
            ...this.authConfig,
            scopes: options?.scopes,
            state: options?.state,
            nonce: options?.nonce,
        }, this.storage);
    }
    /**
     * Build a logout URL to redirect the user to
     * @param options Additional options for building the logout URL
     * @returns The logout URL
     */
    async buildLogoutRedirectUrl(options) {
        return buildLogoutRedirectUrl({
            ...this.authConfig,
            scopes: options?.scopes,
            state: options?.state,
        }, this.storage);
    }
    /**
     * Refresh the current set of OIDC tokens
     * @returns The refreshed tokens
     */
    async refreshTokens() {
        return refreshTokens(this.storage, this.authConfig);
    }
    /**
     * Clear all authentication tokens from storage
     */
    async clearTokens() {
        return clearTokensUtil(this.storage);
    }
}
//# sourceMappingURL=session.js.map