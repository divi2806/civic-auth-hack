import { GenericPublicClientPKCEProducer } from "../services/PKCE.js";
import { OAuth2Client } from "oslo/oauth2";
import { clearTokens, clearUser, exchangeTokens, getEndpointsWithOverrides, retrieveTokens, storeServerTokens, validateOauth2Tokens, } from "../shared/lib/util.js";
import { DEFAULT_AUTH_SERVER } from "../constants.js";
import { CodeVerifier } from "../shared/lib/types.js";
import { loggers } from "../lib/logger.js";
const logger = loggers.services.validation;
export class ServerAuthenticationResolver {
    authConfig;
    storage;
    endpointOverrides;
    pkceProducer;
    oauth2client;
    endpoints;
    constructor(authConfig, storage, endpointOverrides) {
        this.authConfig = authConfig;
        this.storage = storage;
        this.endpointOverrides = endpointOverrides;
        this.pkceProducer = new GenericPublicClientPKCEProducer(storage);
    }
    /**
     * Attempts to refresh tokens if a refresh token is available
     * @param sessionData Current session data
     * @returns Updated session data
     */
    async tryRefreshTokens(sessionData) {
        logger.debug("tryRefreshTokens", { sessionData });
        // If there's a refresh token, attempt to refresh tokens
        if (sessionData?.refreshToken) {
            try {
                // Only attempt refresh if we have necessary components
                if (!this.oauth2client || !this.endpoints?.jwks) {
                    await this.init();
                }
                if (!this.oauth2client || !this.endpoints?.jwks) {
                    throw new Error("Failed to initialize OAuth client for token refresh");
                }
                // Use the oauth2client to refresh the access token
                const tokenResponseBody = await this.oauth2client.refreshAccessToken(sessionData.refreshToken);
                if (!tokenResponseBody) {
                    throw new Error("Failed to get token response from refresh");
                }
                // Validate the refreshed tokens
                await validateOauth2Tokens(tokenResponseBody, this.endpoints.jwks, this.oauth2client, this.oauthServer);
                // Store the refreshed tokens
                await storeServerTokens(this.storage, tokenResponseBody);
                // Construct a refreshed session with the new tokens
                return {
                    authenticated: true,
                    idToken: tokenResponseBody.id_token,
                    accessToken: tokenResponseBody.access_token,
                    refreshToken: tokenResponseBody.refresh_token,
                    accessTokenExpiresAt: tokenResponseBody.access_token_expires_at,
                };
            }
            catch (error) {
                logger.warn("Failed to refresh tokens", error);
                await clearTokens(this.storage);
                await clearUser(this.storage);
                return { ...sessionData, authenticated: false };
            }
        }
        // No refresh token available
        return { ...sessionData, authenticated: false };
    }
    /**
     * returns The session data if the session is valid, otherwise an unauthenticated session
     * @returns {Promise<SessionData>}
     */
    async validateExistingSession(autoRefresh = true) {
        // TODO: investigate a more peformant way to validate a server session
        // other than using JWKS and JWT verification which is what validateOauth2Tokens uses
        const sessionData = await this.getSessionData();
        // If we don't have tokens, try to refresh if we have a refresh token
        if (!sessionData?.idToken || !sessionData.accessToken) {
            if (autoRefresh) {
                const refreshedSessionData = await this.tryRefreshTokens(sessionData);
                if (refreshedSessionData.authenticated) {
                    return refreshedSessionData;
                }
            }
            return { ...sessionData, authenticated: false };
        }
        // Initialize if needed
        if (!this.endpoints?.jwks || !this.oauth2client)
            await this.init();
        if (!this.endpoints?.jwks) {
            throw new Error("JWKS endpoint not found");
        }
        try {
            // Validate existing tokens
            await validateOauth2Tokens({
                access_token: sessionData.accessToken,
                id_token: sessionData.idToken,
                refresh_token: sessionData.refreshToken,
                access_token_expires_at: sessionData.accessTokenExpiresAt,
            }, this.endpoints.jwks, this.oauth2client, this.oauthServer);
            return sessionData;
        }
        catch (error) {
            logger.warn("Error validating tokens", { error, autoRefresh });
            if (autoRefresh) {
                // If token validation fails, try to refresh tokens
                const refreshedSessionData = await this.tryRefreshTokens(sessionData);
                if (refreshedSessionData.authenticated) {
                    return refreshedSessionData;
                }
            }
            return { ...sessionData, authenticated: false };
        }
    }
    get oauthServer() {
        return this.authConfig.oauthServer || DEFAULT_AUTH_SERVER;
    }
    async init() {
        // resolve oauth config
        this.endpoints = await getEndpointsWithOverrides(this.oauthServer, this.endpointOverrides);
        this.oauth2client = new OAuth2Client(this.authConfig.clientId, this.endpoints.auth, this.endpoints.token, {
            redirectURI: this.authConfig.redirectUrl,
        });
        return this;
    }
    async tokenExchange(code, state) {
        if (!this.oauth2client)
            await this.init();
        const codeVerifier = await this.pkceProducer.getCodeVerifier();
        if (!codeVerifier)
            throw new Error("Code verifier not found in storage");
        // exchange auth code for tokens
        const tokens = await exchangeTokens(code, state, this.pkceProducer, this.oauth2client, // clean up types here to avoid the ! operator
        this.oauthServer, this.endpoints);
        await storeServerTokens(this.storage, tokens);
        // the code verifier should be single-use, so we delete it
        await this.storage.delete(CodeVerifier.COOKIE_NAME);
        return tokens;
    }
    async getSessionData() {
        const storageData = await retrieveTokens(this.storage);
        if (!storageData)
            return null;
        return {
            authenticated: !!storageData.id_token,
            idToken: storageData.id_token,
            accessToken: storageData.access_token,
            refreshToken: storageData.refresh_token,
        };
    }
    async getEndSessionEndpoint() {
        if (!this.endpoints) {
            return null;
        }
        return this.endpoints.endsession;
    }
    static async build(authConfig, storage, endpointOverrides) {
        const resolver = new ServerAuthenticationResolver(authConfig, storage, endpointOverrides);
        await resolver.init();
        return resolver;
    }
}
//# sourceMappingURL=ServerAuthenticationResolver.js.map