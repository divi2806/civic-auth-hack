// Proposals for revised versions of the SessionService AKA AuthSessionService
import { BrowserPublicClientPKCEProducer, ConfidentialClientPKCEConsumer, } from "../services/PKCE.js";
import { clearTokens, clearUser, exchangeTokens, generateOauthLoginUrl, generateOauthLogoutUrl, getEndpointsWithOverrides, retrieveTokens, storeTokens, validateOauth2Tokens, } from "../shared/lib/util.js";
import { displayModeFromState, generateState } from "../lib/oauth.js";
import { OAuth2Client } from "oslo/oauth2";
import { LocalStorageAdapter } from "../browser/storage.js";
import { PopupError } from "../services/types.js";
import { removeParamsWithoutReload } from "../lib/windowUtil.js";
import { DEFAULT_AUTH_SERVER, DEFAULT_OAUTH_GET_PARAMS, LOGOUT_STATE, } from "../constants.js";
import { validateLoginAppPostMessage } from "../lib/postMessage.js";
import { getUser } from "../shared/lib/session.js";
import { GenericUserSession } from "../shared/lib/UserSession.js";
import { getIframeRef } from "../shared/lib/iframeUtils.js";
import { v4 as uuid } from "uuid";
import { CodeVerifier } from "../shared/lib/types.js";
import { BrowserAuthenticationRefresher } from "../shared/lib/BrowserAuthenticationRefresher.js";
const defaultSetDesignOptions = (value) => {
    localStorage.setItem("loginAppDesign", JSON.stringify(value));
};
/**
 * An authentication initiator that works on a browser. Since this is just triggering
 * login and logout, session data is not stored here.
 * An associated AuthenticationResolver would be needed to get the session data.
 * Storage is needed for the code verifier, this is the domain of the PKCEConsumer
 * The storage used by the PKCEConsumer should be available to the AuthenticationResolver.
 *
 * Example usage:
 *
 * 1) Client-only SPA -eg a react app with no server:
 * new BrowserAuthenticationInitiator({
 *   pkceConsumer: new BrowserPublicClientPKCEProducer(), // generate and retrieve the challenge client-side
 *   ... other config
 * })
 *
 * 2) Client-side of a client/server app - eg a react app with a backend:
 * new BrowserAuthenticationInitiator({
 *  pkceConsumer: new ConfidentialClientPKCEConsumer("https://myserver.com/pkce"), // get the challenge from the server
 *  ... other config
 * })
 */
export class BrowserAuthenticationInitiator {
    setDesignOptions;
    postMessageHandler = null;
    config;
    setDisplayMode(displayMode) {
        this.config.displayMode = displayMode;
    }
    get displayMode() {
        return this.config.displayMode;
    }
    get isServerTokenExchange() {
        return this.config.pkceConsumer instanceof ConfidentialClientPKCEConsumer;
    }
    get state() {
        return generateState(this.config.displayMode, this.isServerTokenExchange);
    }
    instanceId;
    constructor(config, setDesignOptions = defaultSetDesignOptions) {
        this.setDesignOptions = setDesignOptions;
        this.instanceId = uuid();
        this.config = config;
        this.postMessageHandler = (event) => {
            const thisURL = new URL(window.location.href);
            if (event.origin.endsWith("civic.com") ||
                thisURL.hostname === "localhost") {
                if (!validateLoginAppPostMessage(event.data, this.config.clientId)) {
                    return;
                }
                const loginMessage = event.data;
                if (loginMessage.type === "generatePopupFailed") {
                    this.handleLoginAppPopupFailed(loginMessage.data.url);
                    return;
                }
                if (loginMessage.type === "design") {
                    // TODO handle the design message
                    this.handleLoginAppDesignUpdate(loginMessage.data);
                    return;
                }
            }
        };
        window.addEventListener("message", this.postMessageHandler);
    }
    async handleLoginAppPopupFailed(redirectUrl) {
        console.warn("Login app popup failed open a popup, using redirect mode instead...", redirectUrl);
        window.location.href = redirectUrl;
    }
    async handleLoginAppDesignUpdate(options) {
        this.setDesignOptions(options);
    }
    // Use the config (Client ID, scopes OAuth Server, Endpoints, PKCEConsumer) to generate a new login url
    // and then use the display mode to decide how to send the user there
    async signIn(iframeRef) {
        const url = await generateOauthLoginUrl({
            ...this.config,
            state: this.state,
        });
        if (this.config.displayMode === "iframe") {
            const ref = getIframeRef(iframeRef);
            ref.setAttribute("src", url.toString());
        }
        if (this.config.displayMode === "redirect") {
            window.location.href = url.toString();
        }
        if (this.config.displayMode === "new_tab") {
            try {
                const popupWindow = window.open(url.toString(), "_blank");
                if (!popupWindow) {
                    throw new PopupError("Failed to open popup window");
                }
                // TODO handle the 'onclose' event to clean up and reset the authStatus
            }
            catch (error) {
                console.error("popupWindow", error);
                throw new PopupError("window.open has thrown: Failed to open popup window");
            }
        }
        return url;
    }
    handleIframeUrlChange(iframe, expectedUrl) {
        return new Promise((resolve, reject) => {
            let interval = undefined;
            let timeout = undefined;
            const messageHandler = (event) => {
                if (event.source !== iframe.contentWindow) {
                    // This message did not originate from the iframe. Ignore it.
                    return;
                }
                const message = event.data;
                if (message.source === "civicloginApp" &&
                    (message.type === "auth_error" ||
                        message.type === "auth_error_try_again")) {
                    clearInterval(interval);
                    clearTimeout(timeout);
                    window.removeEventListener("message", messageHandler);
                    reject(new Error(message.data.error || "Authentication failed"));
                    return;
                }
            };
            window.addEventListener("message", messageHandler);
            // Keep the existing URL check logic for success case
            const checkIframe = () => {
                try {
                    const currentUrl = iframe.contentWindow?.location.href;
                    if (currentUrl?.includes(expectedUrl)) {
                        clearInterval(interval);
                        window.removeEventListener("message", messageHandler);
                        resolve();
                    }
                }
                catch {
                    // Ignore cross-origin errors
                }
            };
            interval = setInterval(checkIframe, 100);
            // Timeout after 10 seconds
            timeout = setTimeout(() => {
                clearInterval(interval);
                window.removeEventListener("message", messageHandler);
                reject(new Error("Timeout waiting for iframe URL change"));
            }, 10000);
        });
    }
    async signOut(idToken, iframeRef) {
        let url;
        const localStorage = new LocalStorageAdapter();
        const state = this.state;
        if (this.isServerTokenExchange) {
            if (!this.config.logoutUrl) {
                throw new Error("logoutUrl is required for server token exchange");
            }
            url = new URL(this.config.logoutUrl, window.location.origin);
            url.searchParams.append("state", state);
        }
        else {
            if (!idToken) {
                throw new Error("idToken is required for non-server token exchange");
            }
            url = await generateOauthLogoutUrl({
                ...this.config,
                idToken,
                state,
                redirectUrl: this.config.logoutRedirectUrl,
            });
        }
        if (this.config.displayMode === "iframe") {
            localStorage.delete(LOGOUT_STATE);
            const ref = getIframeRef(iframeRef);
            ref.setAttribute("src", url.toString());
            try {
                await this.handleIframeUrlChange(ref, this.config.logoutRedirectUrl);
                // Clear storage before calling auth server
                await clearTokens(localStorage);
                await clearUser(localStorage);
                LocalStorageAdapter.emitter.emit("signOut");
            }
            catch (error) {
                console.log("Failed to sign out", error);
                // on logout error, trigger the logout-callback directly,
                // if it is a logout from the server, so the the session is cleared
                // and user can still sign out.
                if (this.isServerTokenExchange) {
                    url = new URL(this.config.logoutRedirectUrl, window.location.origin);
                    url.searchParams.append("state", state);
                    // Use the configured basePath if present
                    const appUrl = this.config.basePath
                        ? `${window.location.origin}${this.config.basePath}`
                        : window.location.origin;
                    url.searchParams.append("appUrl", encodeURIComponent(appUrl));
                    ref.setAttribute("src", url.toString());
                }
            }
        }
        if (this.config.displayMode === "redirect") {
            localStorage.set(LOGOUT_STATE, state);
            window.location.href = url.toString();
        }
        if (this.config.displayMode === "new_tab") {
            try {
                const popupWindow = window.open(url.toString(), "_blank");
                if (!popupWindow) {
                    throw new PopupError("Failed to open popup window");
                }
            }
            catch (error) {
                console.error("popupWindow", error);
                throw new PopupError("window.open has thrown: Failed to open popup window");
            }
        }
        return url;
    }
    cleanup() {
        if (this.postMessageHandler) {
            window.removeEventListener("message", this.postMessageHandler);
        }
    }
}
/** A general-purpose authentication initiator, that just generates urls, but lets
 * the caller decide how to use them. This is useful for server-side applications
 * that may serve this URL to their front-ends or just call them directly
 */
export class GenericAuthenticationInitiator {
    config;
    constructor(config) {
        this.config = config;
    }
    // Use the config (Client ID, scopes OAuth Server, Endpoints, PKCEConsumer) to generate a new login url
    // and simply return the url
    async signIn() {
        return generateOauthLoginUrl(this.config);
    }
    async signOut(idToken) {
        return generateOauthLogoutUrl({
            ...this.config,
            idToken,
        });
    }
}
/**
 * An authentication resolver that can run on the browser (i.e. a public client)
 * It uses PKCE for security. PKCE and Session data are stored in local storage
 */
export class BrowserAuthenticationService extends BrowserAuthenticationInitiator {
    pkceProducer;
    oauth2client;
    endpoints;
    // TODO WIP - perhaps we want to keep resolver and initiator separate here
    constructor(config, 
    // Since we are running fully on the client, we produce as well as consume the PKCE challenge
    pkceProducer = new BrowserPublicClientPKCEProducer()) {
        super({
            ...config,
            // Store and retrieve the PKCE challenge in local storage
            pkceConsumer: pkceProducer,
        });
        this.pkceProducer = pkceProducer;
    }
    // TODO too much code duplication here between the browser and the server variant.
    // Suggestion for refactor: Standardise the config for AuthenticationResolvers and create a one-shot
    // function for generating an oauth2client from it
    async init() {
        // resolve oauth config
        this.endpoints = await getEndpointsWithOverrides(this.oauthServer, this.config.endpointOverrides);
        this.oauth2client = new OAuth2Client(this.config.clientId, this.endpoints.auth, this.endpoints.token, {
            redirectURI: this.config.redirectUrl,
        });
        return this;
    }
    async storeTokensOnLogin(tokens) {
        const clientStorage = new LocalStorageAdapter();
        await storeTokens(clientStorage, tokens);
        // delete code verifier as it should be single-use
        await clientStorage.delete(CodeVerifier.COOKIE_NAME);
        const user = await getUser(clientStorage);
        if (!user) {
            throw new Error("Failed to get user info");
        }
        const userSession = new GenericUserSession(clientStorage);
        await userSession.set(user);
        LocalStorageAdapter.emitter.emit("signIn");
    }
    // Two responsibilities:
    // 1. resolve the auth code to get the tokens (should use library code)
    // 2. store the tokens in local storage
    async tokenExchange(code, state) {
        if (!this.oauth2client)
            await this.init();
        const codeVerifier = await this.pkceProducer.getCodeVerifier();
        if (!codeVerifier)
            throw new Error("Code verifier not found in storage");
        // exchange auth code for tokens
        const tokens = await exchangeTokens(code, state, this.pkceProducer, this.oauth2client, // clean up types here to avoid the ! operator
        this.oauthServer, this.endpoints);
        await this.storeTokensOnLogin(tokens);
        // cleanup the browser window if needed
        const parsedDisplayMode = displayModeFromState(state, this.config.displayMode);
        if (parsedDisplayMode === "new_tab") {
            // Close the popup window
            window.addEventListener("beforeunload", () => {
                window?.opener?.focus();
            });
            window.close();
        }
        // these are the default oAuth params that get added to the URL in redirect which we want to remove if present
        removeParamsWithoutReload(DEFAULT_OAUTH_GET_PARAMS);
        return tokens;
    }
    // Get the session data from local storage
    async getSessionData() {
        const storageData = await retrieveTokens(new LocalStorageAdapter());
        if (!storageData)
            return null;
        return {
            authenticated: !!storageData.id_token,
            idToken: storageData.id_token,
            accessToken: storageData.access_token,
            refreshToken: storageData.refresh_token,
            accessTokenExpiresAt: storageData.access_token_expires_at,
        };
    }
    async tryRefreshTokens(sessionData) {
        // If token validation fails but we have a refresh token, attempt to refresh
        if (sessionData?.refreshToken) {
            try {
                const clientStorage = new LocalStorageAdapter();
                // Create a BrowserAuthenticationRefresher to handle token refresh using the build method
                const authConfig = {
                    clientId: this.config.clientId,
                    oauthServer: this.oauthServer,
                    redirectUrl: this.config.redirectUrl,
                };
                // Use build method which handles initialization
                const refresher = await BrowserAuthenticationRefresher.build(authConfig, clientStorage, async (error) => {
                    console.warn("Failed to refresh tokens during validation", error);
                }, this.config.endpointOverrides);
                try {
                    // Perform token refresh (no need to call init explicitly)
                    const tokenResponse = await refresher.refreshAccessToken();
                    // Return a new session with the refreshed tokens
                    const refreshedSession = await this.getSessionData();
                    if (refreshedSession && refreshedSession.authenticated) {
                        await this.storeTokensOnLogin(tokenResponse);
                        return {
                            ...refreshedSession,
                            authenticated: true,
                        };
                    }
                    else {
                        throw new Error("Failed to get refreshed session data");
                    }
                }
                catch (refreshApiError) {
                    console.error("Error during token refresh API call:", refreshApiError);
                    throw refreshApiError; // Re-throw to be caught by outer catch block
                }
            }
            catch (error) {
                const refreshError = error;
                console.error("Token refresh failed with error:", refreshError);
                // Only delete refresh token if it's invalid, not for network errors
                // which might be temporary
                if (refreshError.message.includes("invalid") ||
                    refreshError.message.includes("expired")) {
                    const clientStorage = new LocalStorageAdapter();
                    console.log("Deleting invalid refresh token");
                    await clearTokens(clientStorage);
                    await clearUser(clientStorage);
                }
                console.warn("Failed to refresh tokens", refreshError);
            }
        }
        return {
            ...sessionData,
            authenticated: false,
        };
    }
    async validateExistingSession() {
        try {
            const sessionData = await this.getSessionData();
            if (!sessionData?.idToken || !sessionData.accessToken) {
                const refreshedSessionData = await this.tryRefreshTokens(sessionData);
                if (refreshedSessionData.authenticated) {
                    return refreshedSessionData;
                }
                const unAuthenticatedSession = { ...sessionData, authenticated: false };
                return unAuthenticatedSession;
            }
            if (!this.endpoints?.jwks || !this.oauth2client)
                await this.init();
            if (!this.endpoints?.jwks) {
                throw new Error("No jwks endpoint");
            }
            // this function will throw if any of the tokens are invalid
            await validateOauth2Tokens({
                access_token: sessionData.accessToken,
                id_token: sessionData.idToken,
                refresh_token: sessionData.refreshToken,
                access_token_expires_at: sessionData.accessTokenExpiresAt,
            }, this.endpoints.jwks, this.oauth2client, this.oauthServer);
            return sessionData;
        }
        catch (error) {
            console.warn("Failed to validate existing tokens", error);
            const unAuthenticatedSession = {
                authenticated: false,
            };
            const storage = new LocalStorageAdapter();
            await clearTokens(storage);
            await clearUser(storage);
            return unAuthenticatedSession;
        }
    }
    get oauthServer() {
        return this.config.oauthServer || DEFAULT_AUTH_SERVER;
    }
    async getEndSessionEndpoint() {
        if (!this.endpoints) {
            return null;
        }
        return this.endpoints?.endsession;
    }
    static async build(config) {
        const resolver = new BrowserAuthenticationService(config);
        await resolver.init();
        return resolver;
    }
}
//# sourceMappingURL=AuthenticationService.js.map