import type { DisplayMode, Endpoints, LoginAppDesignOptions, OIDCTokenResponseBody, SessionData } from "../types.js";
import { BrowserPublicClientPKCEProducer } from "../services/PKCE.js";
import type { AuthenticationInitiator, AuthenticationResolver, PKCEConsumer } from "../services/types.js";
export type GenericAuthenticationInitiatorConfig = {
    clientId: string;
    redirectUrl: string;
    state: string;
    scopes: string[];
    oauthServer: string;
    nonce?: string;
    endpointOverrides?: Partial<Endpoints>;
    pkceConsumer: PKCEConsumer;
};
export type BrowserAuthenticationInitiatorConfig = Omit<GenericAuthenticationInitiatorConfig, "state"> & {
    logoutUrl?: string;
    logoutRedirectUrl: string;
    displayMode: DisplayMode;
    basePath?: string;
};
/**
 * An authentication initiator that works on a browser. Since this is just triggering
 * login and logout, session data is not stored here.
 * An associated AuthenticationResolver would be needed to get the session data.
 * Storage is needed for the code verifier, this is the domain of the PKCEConsumer
 * The storage used by the PKCEConsumer should be available to the AuthenticationResolver.
 *
 * Example usage:
 *
 * 1) Client-only SPA -eg a react app with no server:
 * new BrowserAuthenticationInitiator({
 *   pkceConsumer: new BrowserPublicClientPKCEProducer(), // generate and retrieve the challenge client-side
 *   ... other config
 * })
 *
 * 2) Client-side of a client/server app - eg a react app with a backend:
 * new BrowserAuthenticationInitiator({
 *  pkceConsumer: new ConfidentialClientPKCEConsumer("https://myserver.com/pkce"), // get the challenge from the server
 *  ... other config
 * })
 */
export declare class BrowserAuthenticationInitiator implements AuthenticationInitiator {
    readonly setDesignOptions: (value: LoginAppDesignOptions) => void;
    private postMessageHandler;
    protected config: BrowserAuthenticationInitiatorConfig;
    setDisplayMode(displayMode: DisplayMode): void;
    get displayMode(): DisplayMode;
    get isServerTokenExchange(): boolean;
    get state(): string;
    instanceId: string;
    constructor(config: typeof this.config, setDesignOptions?: (value: LoginAppDesignOptions) => void);
    handleLoginAppPopupFailed(redirectUrl: string): Promise<void>;
    handleLoginAppDesignUpdate(options: LoginAppDesignOptions): Promise<void>;
    signIn(iframeRef: HTMLIFrameElement | null): Promise<URL>;
    protected handleIframeUrlChange(iframe: HTMLIFrameElement, expectedUrl: string): Promise<void>;
    signOut(idToken: string | undefined, iframeRef: HTMLIFrameElement | null): Promise<URL>;
    cleanup(): void;
}
/** A general-purpose authentication initiator, that just generates urls, but lets
 * the caller decide how to use them. This is useful for server-side applications
 * that may serve this URL to their front-ends or just call them directly
 */
export declare class GenericAuthenticationInitiator implements AuthenticationInitiator {
    protected config: GenericAuthenticationInitiatorConfig;
    constructor(config: typeof this.config);
    signIn(): Promise<URL>;
    signOut(idToken: string): Promise<URL>;
}
type BrowserAuthenticationConfig = {
    clientId: string;
    redirectUrl: string;
    logoutUrl?: string;
    logoutRedirectUrl: string;
    scopes: string[];
    oauthServer: string;
    endpointOverrides?: Partial<Endpoints>;
    displayMode: DisplayMode;
};
/**
 * An authentication resolver that can run on the browser (i.e. a public client)
 * It uses PKCE for security. PKCE and Session data are stored in local storage
 */
export declare class BrowserAuthenticationService extends BrowserAuthenticationInitiator {
    protected pkceProducer: BrowserPublicClientPKCEProducer;
    private oauth2client;
    private endpoints;
    constructor(config: BrowserAuthenticationConfig, pkceProducer?: BrowserPublicClientPKCEProducer);
    init(): Promise<this>;
    storeTokensOnLogin(tokens: OIDCTokenResponseBody): Promise<void>;
    tokenExchange(code: string, state: string): Promise<OIDCTokenResponseBody>;
    getSessionData(): Promise<SessionData | null>;
    tryRefreshTokens(sessionData: SessionData | null): Promise<SessionData>;
    validateExistingSession(): Promise<SessionData>;
    get oauthServer(): string;
    getEndSessionEndpoint(): Promise<string | null>;
    static build(config: BrowserAuthenticationConfig): Promise<AuthenticationResolver>;
}
export {};
//# sourceMappingURL=AuthenticationService.d.ts.map