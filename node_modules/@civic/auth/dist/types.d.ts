import type { TokenResponseBody } from "oslo/oauth2";
import type { JWTPayload } from "jose";
type UnknownObject = Record<string, unknown>;
type EmptyObject = Record<string, never>;
export declare enum AuthStatus {
    AUTHENTICATED = "authenticated",
    UNAUTHENTICATED = "unauthenticated",
    AUTHENTICATING = "authenticating",
    ERROR = "error",
    SIGNING_OUT = "signing_out"
}
type DisplayMode = "iframe" | "redirect" | "new_tab" | "custom_tab";
type ColorMode = "light" | "dark" | "auto";
interface AuthSessionService {
    loadAuthorizationUrl(authorizationURL: string, displayMode: DisplayMode): void;
    getAuthorizationUrl(scopes: string[], overrideDisplayMode: DisplayMode, nonce?: string): Promise<string>;
    signIn(displayMode: DisplayMode, scopes: string[], nonce?: string): Promise<void>;
    tokenExchange(responseUrl: string): Promise<SessionData>;
    getSessionData(): SessionData;
    updateSessionData(data: SessionData): void;
    getUserInfoService(): Promise<UserInfoService>;
}
interface TokenService {
    exchangeCodeForTokens(authCode: string): Promise<Tokens>;
    validateIdToken(idToken: string, nonce: string): boolean;
    refreshAccessToken(refreshToken: string): Promise<Tokens>;
}
interface UserInfoService {
    getUserInfo<T extends UnknownObject>(accessToken: string, idToken: string | null): Promise<User<T> | null>;
}
interface ResourceService {
    getProtectedResource(accessToken: string): Promise<unknown>;
}
type AuthRequest = {
    clientId: string;
    redirectUri: string;
    state: string;
    nonce: string;
    scope: string;
};
type Endpoints = {
    jwks: string;
    auth: string;
    token: string;
    userinfo: string;
    challenge?: string;
    endsession: string;
};
type Config = {
    oauthServer: string;
    endpoints?: Endpoints;
};
type SessionData = {
    authenticated: boolean;
    state?: string;
    accessToken?: string;
    refreshToken?: string;
    idToken?: string;
    accessTokenExpiresAt?: number;
    codeVerifier?: string;
    displayMode?: DisplayMode;
    openerUrl?: string;
};
type OIDCTokenResponseBody = TokenResponseBody & {
    id_token: string;
    access_token_expires_at?: number;
};
type ParsedTokens = {
    id_token: JWTPayload;
    access_token: JWTPayload;
    refresh_token?: string;
};
type ForwardedTokens = Record<string, {
    idToken?: string;
    accessToken?: string;
    refreshToken?: string;
}>;
type ForwardedTokensJWT = Record<string, {
    id_token?: string;
    access_token?: string;
    refresh_token?: string;
    scope?: string;
}>;
type IdTokenPayload = JWTPayload & {
    forwardedTokens?: ForwardedTokensJWT;
    email?: string;
    name?: string;
    picture?: string;
    nonce: string;
    at_hash: string;
};
declare const tokenKeys: readonly ["sub", "idToken", "accessToken", "refreshToken", "forwardedTokens"];
export type OAuthTokens = {
    idToken?: string;
    accessToken?: string;
    refreshToken?: string;
};
type Tokens = {
    [K in (typeof tokenKeys)[number]]: K extends "forwardedTokens" ? ForwardedTokens : string;
};
type BaseUser = {
    id: string;
    email?: string;
    username?: string;
    name?: string;
    given_name?: string;
    family_name?: string;
    picture?: string;
    updated_at?: Date;
};
type User<T extends UnknownObject | EmptyObject = EmptyObject> = T extends EmptyObject ? BaseUser : BaseUser & T;
type OpenIdConfiguration = {
    authorization_endpoint: string;
    claims_parameter_supported: boolean;
    claims_supported: string[];
    code_challenge_methods_supported: string[];
    end_session_endpoint: string;
    grant_types_supported: string[];
    issuer: string;
    jwks_uri: string;
    authorization_response_iss_parameter_supported: boolean;
    response_modes_supported: string[];
    response_types_supported: string[];
    scopes_supported: string[];
    subject_types_supported: string[];
    token_endpoint_auth_methods_supported: string[];
    token_endpoint_auth_signing_alg_values_supported: string[];
    token_endpoint: string;
    id_token_signing_alg_values_supported: string[];
    pushed_authorization_request_endpoint: string;
    request_parameter_supported: boolean;
    request_uri_parameter_supported: boolean;
    userinfo_endpoint: string;
    claim_types_supported: string[];
};
type LoginPostMessage = {
    source: string;
    type: string;
    clientId: string;
    data: {
        url: string;
    } | LoginAppDesignOptions;
};
export type IframeAuthMessage = {
    source: "civicloginApp";
    type: "auth_error" | "auth_error_try_again";
    clientId: string;
    data: {
        url?: string;
        error?: string;
    };
};
export type LoginAppDesignOptions = {
    colorMode: ColorMode;
};
export type { LoginPostMessage, AuthSessionService, TokenService, UserInfoService, ResourceService, AuthRequest, Tokens, Endpoints, Config, SessionData, OIDCTokenResponseBody, ParsedTokens, BaseUser, User, DisplayMode, UnknownObject, EmptyObject, ForwardedTokens, ForwardedTokensJWT, IdTokenPayload, OpenIdConfiguration, ColorMode, };
export { tokenKeys };
export interface AuthStorage {
    get(key: string): Promise<string | null>;
    set(key: string, value: string): Promise<void>;
    delete(key: string): Promise<void>;
}
export type IframeMode = "embedded" | "modal";
//# sourceMappingURL=types.d.ts.map