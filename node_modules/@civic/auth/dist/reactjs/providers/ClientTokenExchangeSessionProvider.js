"use client";
import { jsx as _jsx } from "@emotion/react/jsx-runtime";
import React, { createContext, useCallback, useEffect, useMemo, useState, useRef, } from "react";
import { BrowserAuthenticationService } from "../../services/AuthenticationService.js";
import { isWindowInIframe } from "../../lib/windowUtil.js";
import { AuthStatus } from "../../types.js";
import { useCurrentUrl, useCivicAuthConfig, useSignIn, useIframe, } from "../../shared/hooks/index.js";
import { LocalStorageAdapter } from "../../browser/storage.js";
import { getIframeRef } from "../../shared/lib/iframeUtils.js";
const defaultSession = {
    data: {
        authenticated: false,
        idToken: undefined,
        accessToken: undefined,
        displayMode: "iframe",
    },
    error: null,
    isLoading: false,
    doTokenExchange: null,
};
// Context for exposing session specifically to the TokenProvider
const ClientTokenExchangeSessionContext = createContext(defaultSession);
const ClientTokenExchangeSessionProvider = ({ children, }) => {
    const authConfig = useCivicAuthConfig();
    const [authService, setAuthService] = useState();
    const [error, setError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [session, setSession] = useState(null);
    const { iframeRef } = useIframe();
    const currentUrl = useCurrentUrl();
    // Use the signIn hook with iframe displayMode
    const { startSignIn, authStatus } = useSignIn({
        displayMode: authConfig?.displayMode || "iframe",
    });
    // Add a ref to track processed codes
    const processedCodes = useRef(new Set());
    useEffect(() => {
        if (!currentUrl || !authConfig)
            return;
        const { redirectUrl, clientId, oauthServer, scopes, logoutRedirectUrl, logoutUrl, } = authConfig;
        BrowserAuthenticationService.build({
            clientId,
            redirectUrl,
            logoutRedirectUrl,
            logoutUrl,
            oauthServer,
            scopes,
            displayMode: "iframe",
        }).then(setAuthService);
    }, [currentUrl, authConfig]);
    const isInIframe = isWindowInIframe(globalThis.window);
    const doTokenExchange = useCallback(async (inUrl) => {
        if (!authService)
            return;
        const url = new URL(inUrl);
        const code = url.searchParams.get("code");
        const state = url.searchParams.get("state");
        // Create a unique key for this code/state combination
        const exchangeKey = `${code}:${state}`;
        // If we've already processed this code, skip it
        if (processedCodes.current.has(exchangeKey)) {
            console.log("Token exchange already processed for this code");
            return;
        }
        if (code && state) {
            try {
                // Mark this code as processed before starting the exchange
                processedCodes.current.add(exchangeKey);
                setIsLoading(true);
                await authService.tokenExchange(code, state);
            }
            catch (error) {
                setError(error);
                setSession({ authenticated: false });
            }
            setIsLoading(false);
        }
    }, [authService]);
    const onSignIn = useCallback(async () => {
        if (!authService)
            return;
        const session = await authService.getSessionData();
        setSession(session);
    }, [authService]);
    const onSignOut = useCallback(() => {
        setSession(null);
    }, []);
    useEffect(() => {
        LocalStorageAdapter.emitter.on("signIn", onSignIn);
        LocalStorageAdapter.emitter.on("signOut", onSignOut);
        return () => {
            LocalStorageAdapter.emitter.off("signIn", onSignIn);
            LocalStorageAdapter.emitter.off("signOut", onSignOut);
        };
    }, [onSignIn, onSignOut]);
    useEffect(() => {
        if (!authConfig) {
            setIsLoading(true);
        }
        else {
            setIsLoading(false);
        }
    }, [authConfig]);
    const [validationInProgress, setValidationInProgress] = useState(false);
    // Handle page load or refocus
    useEffect(() => {
        if (!authConfig?.redirectUrl ||
            !authService ||
            !currentUrl ||
            isInIframe ||
            isLoading) {
            return;
        }
        // We specifically don't want to abort token refresh operations
        // The AbortController is mainly used to prevent token exchange after unmount
        const abortController = new AbortController();
        const onPageLoad = async () => {
            if (validationInProgress || authStatus === AuthStatus.SIGNING_OUT)
                return;
            // if we have existing tokens, then validate them and return the session data
            // otherwise check if we have a code in the url and exchange it for tokens
            // if we have neither, initiate sign-in flow
            setValidationInProgress(true);
            try {
                const existingSessionData = await authService.validateExistingSession();
                if (existingSessionData.authenticated) {
                    setSession(existingSessionData);
                    return;
                }
                // If we have a code in the URL, attempt token exchange
                if (new URL(currentUrl).searchParams.get("code")) {
                    await doTokenExchange(currentUrl);
                    return;
                }
                // No valid session and no code in URL - initiate sign-in
                // But only if we're not in an iframe (to prevent infinite loops in embedded scenarios)
                if (!isInIframe && authConfig) {
                    const ref = getIframeRef(iframeRef?.current, true);
                    if (ref && authConfig?.displayMode === "iframe") {
                        startSignIn();
                    }
                }
            }
            catch (error) {
                console.error("Error during session validation:", error);
            }
            finally {
                setValidationInProgress(false);
            }
        };
        onPageLoad();
        return () => {
            abortController.abort();
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        authConfig,
        authService,
        currentUrl,
        doTokenExchange,
        isInIframe,
        isLoading,
        startSignIn,
    ]);
    const value = useMemo(() => ({
        data: session,
        error,
        isLoading,
        doTokenExchange: authService ? doTokenExchange : null,
    }), [session, error, isLoading, authService, doTokenExchange]);
    return (_jsx(ClientTokenExchangeSessionContext.Provider, { value: value, children: children }));
};
export { ClientTokenExchangeSessionProvider, ClientTokenExchangeSessionContext, };
//# sourceMappingURL=ClientTokenExchangeSessionProvider.js.map