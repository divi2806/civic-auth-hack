import { AUTH_SERVER_LEGACY_SESSION, AUTH_SERVER_SESSION, OAuthTokenTypes, } from "./types.js";
import { OAuth2Client } from "oslo/oauth2";
import { getIssuerVariations, getOauthEndpoints } from "../../lib/oauth.js";
import * as jose from "jose";
import { withoutUndefined } from "../../utils.js";
import { GenericUserSession } from "../../shared/lib/UserSession.js";
import { decodeJwt } from "jose";
import { AUTOREFRESH_TIMEOUT_NAME, LOGOUT_STATE, REFRESH_IN_PROGRESS, } from "../../constants.js";
import { loggers } from "../../lib/logger.js";
const logger = loggers.services.validation;
/**
 * Given a PKCE code verifier, derive the code challenge using SHA
 */
export async function deriveCodeChallenge(codeVerifier, method = "S256") {
    if (method === "Plain") {
        console.warn("Using insecure plain code challenge method");
        return codeVerifier;
    }
    const encoder = new TextEncoder();
    const data = encoder.encode(codeVerifier);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "");
}
export async function getEndpointsWithOverrides(oauthServer, endpointOverrides = {}) {
    const endpoints = await getOauthEndpoints(oauthServer);
    return {
        ...endpoints,
        ...endpointOverrides,
    };
}
export async function generateOauthLoginUrl(config) {
    const endpoints = await getEndpointsWithOverrides(config.oauthServer, config.endpointOverrides);
    const oauth2Client = buildOauth2Client(config.clientId, config.redirectUrl, endpoints);
    const challenge = await config.pkceConsumer.getCodeChallenge();
    const oAuthUrl = await oauth2Client.createAuthorizationURL({
        state: config.state,
        scopes: config.scopes,
    });
    // The OAuth2 client supports PKCE, but does not allow passing in a code challenge from some other source
    // It only allows passing in a code verifier which it then hashes itself.
    oAuthUrl.searchParams.append("code_challenge", challenge);
    oAuthUrl.searchParams.append("code_challenge_method", "S256");
    if (config.nonce) {
        // nonce isn't supported by oslo, so we add it manually
        oAuthUrl.searchParams.append("nonce", config.nonce);
    }
    // Required by the auth server for offline_access scope
    oAuthUrl.searchParams.append("prompt", "consent");
    return oAuthUrl;
}
export async function generateOauthLogoutUrl(config) {
    const endpoints = await getEndpointsWithOverrides(config.oauthServer, config.endpointOverrides);
    const endSessionUrl = new URL(endpoints.endsession);
    endSessionUrl.searchParams.append("client_id", config.clientId);
    endSessionUrl.searchParams.append("id_token_hint", config.idToken);
    endSessionUrl.searchParams.append("state", config.state);
    endSessionUrl.searchParams.append("post_logout_redirect_uri", config.redirectUrl);
    return endSessionUrl;
}
export function buildOauth2Client(clientId, redirectUri, endpoints) {
    return new OAuth2Client(clientId, endpoints.auth, endpoints.token, {
        redirectURI: redirectUri,
    });
}
export async function exchangeTokens(code, state, pkceProducer, oauth2Client, oauthServer, endpoints) {
    const codeVerifier = await pkceProducer.getCodeVerifier();
    if (!codeVerifier)
        throw new Error("Code verifier not found in state");
    const tokens = await oauth2Client.validateAuthorizationCode(code, {
        codeVerifier,
    });
    // Validate relevant tokens
    try {
        await validateOauth2Tokens(tokens, endpoints.jwks, oauth2Client, oauthServer);
    }
    catch (error) {
        console.error("tokenExchange error", { error, tokens });
        throw new Error(`OIDC tokens validation failed: ${error.message}`);
    }
    return tokens;
}
/**
 * Calculates the maxAge values for access and refresh token cookies
 * based on the TTL values in the access token
 *
 * maxAge needs to be in seconds from now until expiration
 *
 * @param tokens OIDC tokens response containing the access token
 * @returns Object with accessTokenMaxAge and refreshTokenMaxAge in seconds
 */
export const getCookiesMaxAge = (tokens) => {
    const parsedAccessToken = decodeJwt(tokens.access_token);
    // Get TTL values from the token or use defaults
    const accessTokenTTL = Number(parsedAccessToken?.accessTokenTTL) || 60 * 60; // 1 hour default
    const refreshTokenTTL = Number(parsedAccessToken?.refreshTokenTTL) || 60 * 60 * 24 * 30; // 30 days default
    // Calculate maxAge as TTL values directly (they represent seconds from now)
    // This is correct because TTL values represent the lifetime of the token
    const accessTokenMaxAge = accessTokenTTL;
    const refreshTokenMaxAge = refreshTokenTTL;
    return {
        accessTokenMaxAge,
        refreshTokenMaxAge,
    };
};
export const getAccessTokenExpiresAt = (tokens) => {
    const parsedAccessToken = decodeJwt(tokens.access_token);
    if (parsedAccessToken?.exp || false) {
        return parsedAccessToken.exp;
    }
    else if (tokens.expires_in) {
        const now = Math.floor(new Date().getTime() / 1000);
        return now + tokens.expires_in;
    }
    else {
        throw new Error("Cannot determine access token expiry!");
    }
};
export async function setAccessTokenExpiresAt(storage, tokens) {
    // try to extract absolute expiry time from access token but fallback to calculation if not possible
    const accessTokenExpiresAt = getAccessTokenExpiresAt(tokens);
    await storage.set(OAuthTokenTypes.ACCESS_TOKEN_EXPIRES_AT, accessTokenExpiresAt.toString());
}
export async function storeTokens(storage, tokens) {
    await storage.set(OAuthTokenTypes.ID_TOKEN, tokens.id_token);
    await storage.set(OAuthTokenTypes.ACCESS_TOKEN, tokens.access_token);
    if (tokens.refresh_token) {
        await storage.set(OAuthTokenTypes.REFRESH_TOKEN, tokens.refresh_token);
    }
    await setAccessTokenExpiresAt(storage, tokens);
}
/**
 * Stores tokens in server-side cookies with appropriate expiration times
 * Uses TTL values from the tokens to set cookie maxAge values
 */
export async function storeServerTokens(storage, tokens) {
    const accessTokenExpiresAt = getAccessTokenExpiresAt(tokens);
    const cookieStorage = storage;
    const now = Math.floor(Date.now() / 1000);
    // Get maxAge values based on token TTLs
    const { refreshTokenMaxAge, accessTokenMaxAge } = getCookiesMaxAge(tokens);
    // Apply maxAge to cookie options
    const accessTokenCookieOptions = {
        maxAge: accessTokenMaxAge,
    };
    const refreshTokenCookieOptions = {
        maxAge: refreshTokenMaxAge,
    };
    // Set ID token with expiry based on the exp claim
    const idTokenExpiry = decodeJwt(tokens.id_token)?.exp;
    const idTokenMaxAge = idTokenExpiry ? idTokenExpiry - now : accessTokenMaxAge;
    await cookieStorage.set(OAuthTokenTypes.ID_TOKEN, tokens.id_token, {
        maxAge: idTokenMaxAge,
    });
    // Set access token
    await cookieStorage.set(OAuthTokenTypes.ACCESS_TOKEN, tokens.access_token, accessTokenCookieOptions);
    // Set refresh token if present
    if (tokens.refresh_token) {
        await cookieStorage.set(OAuthTokenTypes.REFRESH_TOKEN, tokens.refresh_token, refreshTokenCookieOptions);
    }
    // Store the access token expiration timestamp
    await storage.set(OAuthTokenTypes.ACCESS_TOKEN_EXPIRES_AT, accessTokenExpiresAt.toString(), accessTokenCookieOptions);
    logger.debug("storeServerTokens", {
        accessTokenExpiresAt,
        refreshTokenMaxAge,
        accessTokenMaxAge,
        idTokenMaxAge,
    });
}
export async function clearTokens(storage) {
    // clear all local storage keys related to OAuth and CivicAuth SDK
    const clearOAuthPromises = [
        ...Object.values(OAuthTokenTypes),
        REFRESH_IN_PROGRESS,
        AUTOREFRESH_TIMEOUT_NAME,
        LOGOUT_STATE,
    ].map(async (key) => {
        await storage.delete(key);
    });
    await Promise.all([...clearOAuthPromises]);
}
export async function clearAuthServerSession(storage) {
    await storage.delete(AUTH_SERVER_SESSION);
    await storage.delete(AUTH_SERVER_LEGACY_SESSION);
}
export async function clearUser(storage) {
    const userSession = new GenericUserSession(storage);
    await userSession.clear();
}
export async function retrieveTokens(storage) {
    const idToken = await storage.get(OAuthTokenTypes.ID_TOKEN);
    const accessToken = await storage.get(OAuthTokenTypes.ACCESS_TOKEN);
    const refreshToken = await storage.get(OAuthTokenTypes.REFRESH_TOKEN);
    const accessTokenExpiresAt = await storage.get(OAuthTokenTypes.ACCESS_TOKEN_EXPIRES_AT);
    return {
        id_token: idToken ?? undefined,
        access_token: accessToken ?? undefined,
        refresh_token: refreshToken ?? undefined,
        access_token_expires_at: accessTokenExpiresAt !== null
            ? parseInt(accessTokenExpiresAt, 10)
            : undefined, // Convert string to number
    };
}
export async function retrieveAccessTokenExpiresAt(storage) {
    return Number(await storage.get(OAuthTokenTypes.ACCESS_TOKEN_EXPIRES_AT));
}
// Single JWKS instance that persists for the lifetime of the SDK session
let cachedJWKS = null;
let cachedJwksUrl = null;
export async function validateOauth2Tokens(tokens, jwksEndpoint, oauth2Client, issuer) {
    // Only create a new JWKS instance if one doesn't exist yet
    if (!cachedJWKS || cachedJwksUrl !== jwksEndpoint) {
        cachedJWKS = jose.createRemoteJWKSet(new URL(jwksEndpoint));
        cachedJwksUrl = jwksEndpoint;
    }
    // validate the ID token
    const idTokenResponse = await jose.jwtVerify(tokens.id_token, cachedJWKS, {
        issuer: getIssuerVariations(issuer),
        audience: oauth2Client.clientId,
    });
    // validate the access token
    const accessTokenResponse = await jose.jwtVerify(tokens.access_token, cachedJWKS, {
        issuer: getIssuerVariations(issuer),
    });
    return withoutUndefined({
        id_token: idTokenResponse.payload,
        access_token: accessTokenResponse.payload,
        refresh_token: tokens.refresh_token,
    });
}
//# sourceMappingURL=util.js.map