"use client";
import { jsx as _jsx, jsxs as _jsxs } from "@emotion/react/jsx-runtime";
import React, { useCallback, useEffect, useRef, useState } from "react";
import { LoadingIcon } from "../../shared/components/LoadingIcon.js";
import { CloseIcon } from "../../shared/components/CloseIcon.js";
import { CivicAuthIframe } from "../../shared/components/CivicAuthIframe.js";
import { useIframe } from "../../shared/hooks/index.js";
import { TOKEN_EXCHANGE_TRIGGER_TEXT } from "../../constants.js";
import { useCivicAuthConfig } from "../../shared/hooks/index.js";
import { useClientTokenExchangeSession } from "../../shared/hooks/index.js";
import { getIframeRef } from "../lib/iframeUtils.js";
import { useIsClient } from "usehooks-ts";
function NoChrome({ children, }) {
    return (_jsx("div", { "data-testid": "civic-iframe-no-chrome", style: { position: "relative" }, children: children }));
}
export function IframeChrome({ children, onClose, isFrameLoaded, }) {
    const { setIframeAborted } = useIframe();
    return (_jsx("div", { style: {
            position: "absolute",
            left: 0,
            top: 0,
            zIndex: 50,
            display: "flex",
            height: "100vh",
            width: "100vw",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "rgba(17, 24, 39, 0.5)",
            backdropFilter: "blur(4px)",
        }, onClick: () => {
            setIframeAborted(true);
            onClose?.();
        }, children: _jsxs("div", { "data-testid": "iframe-chrome", style: {
                position: "relative",
                overflow: "hidden",
                paddingLeft: "0",
                paddingRight: "0",
                paddingBottom: "0",
                width: "20rem",
            }, onClick: (e) => e.stopPropagation(), children: [isFrameLoaded && (_jsx("button", { style: {
                        position: "absolute",
                        right: "0.6rem",
                        top: "0.6rem",
                        cursor: "pointer",
                        alignItems: "center",
                        justifyContent: "center",
                        border: "none",
                        backgroundColor: "transparent",
                        padding: "0.25rem",
                        color: "#9ca3af",
                        zIndex: 100,
                    }, onClick: () => {
                        setIframeAborted(true);
                        onClose?.();
                    }, children: _jsx(CloseIcon, {}) })), children] }) }));
}
const CivicAuthIframeContainer = ({ onClose, closeOnRedirect = true, }) => {
    const config = useCivicAuthConfig();
    const [tokenExchangeUrl, setTokenExchangeUrl] = useState(null);
    const { doTokenExchange } = useClientTokenExchangeSession();
    const { iframeRef, iframeMode, backgroundColor, setIframeMounted } = useIframe();
    const [isIframeContentLoaded, setIsIframeContentLoaded] = useState(false);
    useEffect(() => {
        setIframeMounted(true);
    }, [setIframeMounted]);
    useEffect(() => {
        if (tokenExchangeUrl) {
            doTokenExchange?.(tokenExchangeUrl);
        }
    }, [doTokenExchange, tokenExchangeUrl]);
    const processIframeUrl = useCallback(() => {
        if (!config)
            return;
        if (iframeRef && iframeRef.current) {
            const ref = getIframeRef(iframeRef.current);
            if (ref.contentWindow) {
                try {
                    const iframeUrl = ref.contentWindow.location.href;
                    // we know that oauth has finished when the iframe redirects to our redirectUrl
                    if (iframeUrl.startsWith(config.redirectUrl)) {
                        const iframeBody = ref.contentWindow.document.body.innerHTML;
                        // If we're doing a server token exchange, we need to call the server a second time
                        // using a fetch so that we're on the same domain and cookies can be sent and read
                        // The server will use the presence of the code_verifier cookie to determine whether to do a token exchange or not.
                        // On the initial (3rd party) redirect from the auth server, the cookie won't be sent, so the server-side callback route will just render a blank page,
                        // and we'll do the exchange request from here, which will include the cookies.
                        if (iframeBody.includes(TOKEN_EXCHANGE_TRIGGER_TEXT)) {
                            const params = new URL(iframeUrl).searchParams;
                            const appUrl = globalThis.window?.location?.origin;
                            fetch(`${config.redirectUrl}?${params.toString()}&appUrl=${appUrl}`);
                        }
                        else {
                            // if we're doing token-exchange in the client, we can just set the authResponseUrl
                            // to be handled by the auth provider
                            // iframeRef.current.setAttribute("src", "");
                            setTokenExchangeUrl(iframeUrl);
                        }
                        if (closeOnRedirect)
                            onClose?.();
                        return true; // Successfully processed the URL
                    }
                }
                catch {
                    // ignore errors while waiting for redirect
                }
            }
        }
        return false; // Haven't processed the URL yet
    }, [closeOnRedirect, config, iframeRef, onClose]);
    const intervalId = useRef();
    const handleEscape = useCallback((event) => {
        if (event.key === "Escape") {
            onClose?.();
        }
    }, [onClose]);
    // handle Escape
    useEffect(() => {
        window.addEventListener("keydown", handleEscape);
        return () => window.removeEventListener("keydown", handleEscape);
    });
    const handleIframeLoad = useCallback(() => {
        setIsIframeContentLoaded(true);
        const iframeHasUrl = processIframeUrl();
        if (iframeHasUrl && intervalId.current) {
            clearInterval(intervalId.current);
        }
    }, [processIframeUrl, intervalId]);
    const WrapperComponent = iframeMode === "embedded" ? NoChrome : IframeChrome;
    const isClient = useIsClient();
    // if the iframe is embedded, we need to handle the loading state differently
    if (iframeMode === "embedded") {
        return (_jsx(WrapperComponent, { onClose: onClose, isFrameLoaded: isIframeContentLoaded, children: _jsxs("div", { style: {
                    minHeight: isIframeContentLoaded ? "auto" : "225px",
                    backgroundColor: isClient ? backgroundColor : "#8E949D",
                    borderRadius: "24px",
                    position: "relative",
                    transition: "all 0.5s ease-in-out",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    overflow: "hidden",
                }, children: [!isIframeContentLoaded && (_jsx("div", { style: {
                            position: "absolute",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                        }, children: _jsx(LoadingIcon, {}) })), _jsx("div", { style: {
                            width: "100%",
                            minWidth: "100%",
                            alignItems: "center",
                            justifyContent: "center",
                            borderRadius: "24px",
                            overflow: "hidden",
                            opacity: isIframeContentLoaded ? 1 : 0,
                            transition: "opacity 0.5s ease-in-out",
                        }, children: _jsx(CivicAuthIframe, { ref: iframeRef, id: "civic-auth-iframe", onLoad: handleIframeLoad }) })] }) }));
    }
    // if the iframe is not embedded, we can just render the iframe directly
    return (_jsx(WrapperComponent, { onClose: onClose, isFrameLoaded: isIframeContentLoaded, children: _jsx(CivicAuthIframe, { ref: iframeRef, id: "civic-auth-iframe", onLoad: handleIframeLoad }) }));
};
export { CivicAuthIframeContainer };
//# sourceMappingURL=CivicAuthIframeContainer.js.map