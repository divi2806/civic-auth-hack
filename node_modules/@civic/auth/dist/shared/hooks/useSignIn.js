import { BrowserAuthenticationInitiator } from "../../services/AuthenticationService.js";
import { BrowserPublicClientPKCEProducer } from "../../services/PKCE.js";
import { useCivicAuthConfig } from "../../shared/hooks/useCivicAuthConfig.js";
import { AuthStatus, } from "../../types.js";
import { useIframe } from "../../shared/hooks/useIframe.js";
import { useCallback, useEffect, useMemo, useRef } from "react";
import { PopupError } from "../../services/types.js";
import { useSession } from "./useSession.js";
import { LocalStorageAdapter } from "../../browser/storage.js";
import { clearTokens, clearUser } from "../lib/util.js";
import { useLocalStorage } from "usehooks-ts";
import { LOGOUT_STATE } from "../../constants.js";
import { useAuthStatus } from "../../shared/providers/AuthStatusContext.js";
const SIGN_IN_TIMEOUT_MS = 9 * 60 * 1000; // 9 minutes in milliseconds
const useSignIn = ({ pkceConsumer, preSignOut, postSignOut, displayMode } = {
    displayMode: "iframe",
}) => {
    const civicAuthConfig = useCivicAuthConfig();
    const { iframeRef, logoutIframeRef, setIframeIsVisible, iframeIsVisible, setLogoutIframeIsVisible, iframeAborted, setIframeAborted, } = useIframe();
    const { data: session } = useSession();
    // Use the shared auth status from context instead of local state
    const { authStatus, setAuthStatus } = useAuthStatus();
    const [, setDesignOption] = useLocalStorage(`loginAppDesign`, { colorMode: "auto" });
    const timeoutRef = useRef(null);
    const authStatusRef = useRef(AuthStatus.UNAUTHENTICATED);
    const authInitiator = useMemo(() => {
        if (!civicAuthConfig) {
            return null;
        }
        const { clientId, redirectUrl, logoutUrl, logoutRedirectUrl, nonce, oauthServer, endpoints, scopes, } = civicAuthConfig;
        return new BrowserAuthenticationInitiator({
            pkceConsumer: pkceConsumer || new BrowserPublicClientPKCEProducer(), // generate and retrieve the challenge client-side
            clientId,
            redirectUrl,
            logoutUrl,
            logoutRedirectUrl,
            scopes,
            displayMode,
            oauthServer,
            endpointOverrides: endpoints,
            nonce,
        }, setDesignOption);
    }, [civicAuthConfig, displayMode, pkceConsumer, setDesignOption]);
    useEffect(() => {
        return () => {
            // Clean up on unmount
            if (authInitiator) {
                authInitiator.cleanup();
            }
            // Clear any existing timeout
            if (timeoutRef.current !== null) {
                window.clearTimeout(timeoutRef.current);
                timeoutRef.current = null;
            }
        };
    }, [authInitiator]);
    // This effect is used to clear the tokens and user when the user signs out after a redirect
    useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const state = params.get("state");
        const localStorage = new LocalStorageAdapter();
        localStorage.get(LOGOUT_STATE).then((storedLogoutState) => {
            if (state && state === storedLogoutState) {
                // Clear storage
                clearTokens(localStorage);
                clearUser(localStorage);
                LocalStorageAdapter.emitter.emit("signOut");
                // Clean up storage and URL
                sessionStorage.removeItem(LOGOUT_STATE);
                const cleanUrl = window.location.href.split("?")[0];
                window.history.replaceState({}, document.title, cleanUrl);
            }
        });
    }, []);
    const startSignIn = useCallback(async () => {
        if (!authInitiator)
            return;
        if (![AuthStatus.UNAUTHENTICATED, AuthStatus.ERROR].includes(authStatus)) {
            return;
        }
        // Clear any existing timeout
        if (timeoutRef.current !== null) {
            window.clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
        setAuthStatus(AuthStatus.AUTHENTICATING);
        authInitiator.setDisplayMode(displayMode);
        // Set a timeout to reset authentication state and retry if still authenticating
        timeoutRef.current = window.setTimeout(() => {
            // Check the current auth status via ref when the timeout fires
            if (authStatusRef.current === AuthStatus.AUTHENTICATING) {
                console.log("Sign-in timeout reached. Resetting authentication state.");
                setAuthStatus(AuthStatus.UNAUTHENTICATED);
                // Call startSignIn again to restart with fresh state
                startSignIn();
            }
        }, SIGN_IN_TIMEOUT_MS);
        const useIframeRef = iframeRef?.current || null;
        await authInitiator.signIn(useIframeRef).catch((error) => {
            setAuthStatus(AuthStatus.ERROR);
            console.error("signIn error", {
                error,
                isPopupError: error instanceof PopupError,
            });
            // if we've tried to open a popup and it has failed, then fallback to redirect mode
            if (error instanceof PopupError) {
                setIframeIsVisible(false); // hide the iframe
                authInitiator.cleanup(); // clear any event listeners from before
                authInitiator.setDisplayMode("redirect"); // switch to redirect mode
                authInitiator.signIn(useIframeRef); // retry the sign in
            }
        });
    }, [
        authInitiator,
        displayMode,
        iframeRef,
        setIframeIsVisible,
        authStatus,
        setAuthStatus,
    ]);
    const signIn = useCallback(async () => {
        if (displayMode === "iframe") {
            setIframeIsVisible(true);
        }
        return startSignIn();
    }, [startSignIn, displayMode, setIframeIsVisible]);
    const signOut = useCallback(async () => {
        const idToken = session?.idToken;
        if (!authInitiator)
            return;
        setAuthStatus(AuthStatus.SIGNING_OUT);
        if (displayMode === "iframe") {
            setIframeIsVisible(false);
            setLogoutIframeIsVisible(true);
        }
        try {
            await preSignOut?.();
            const useIframeRef = logoutIframeRef?.current || null;
            await authInitiator.signOut(idToken, useIframeRef).catch((error) => {
                setAuthStatus(AuthStatus.ERROR);
                console.error("signOut error", {
                    error,
                    isPopupError: error instanceof PopupError,
                });
                // Same popup fallback as signIn
                if (error instanceof PopupError) {
                    setLogoutIframeIsVisible(false);
                    authInitiator.cleanup();
                    authInitiator.setDisplayMode("redirect");
                    authInitiator.signOut(idToken, useIframeRef);
                }
            });
        }
        catch (error) {
            console.error("Signout error:", error);
        }
    }, [
        session?.idToken,
        authInitiator,
        displayMode,
        setLogoutIframeIsVisible,
        setIframeIsVisible,
        preSignOut,
        logoutIframeRef,
        setAuthStatus,
    ]);
    // Keep the authStatusRef in sync with authStatus
    useEffect(() => {
        authStatusRef.current = authStatus;
        if (authStatus !== AuthStatus.AUTHENTICATING &&
            timeoutRef.current !== null) {
            window.clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
    }, [authStatus]);
    useEffect(() => {
        if (session?.authenticated) {
            setAuthStatus(AuthStatus.AUTHENTICATED);
            // Clear timeout when authentication is successful
            if (timeoutRef.current !== null) {
                window.clearTimeout(timeoutRef.current);
                timeoutRef.current = null;
            }
        }
        if (displayMode === "iframe" && iframeAborted) {
            setIframeAborted(false);
            // Clear timeout when iframe is aborted
            if (timeoutRef.current !== null) {
                window.clearTimeout(timeoutRef.current);
                timeoutRef.current = null;
            }
        }
        if (!session?.authenticated) {
            setAuthStatus(AuthStatus.UNAUTHENTICATED);
        }
    }, [
        displayMode,
        iframeAborted,
        session?.authenticated,
        setIframeAborted,
        setAuthStatus,
    ]);
    // handle logout finished
    useEffect(() => {
        if (authStatus === AuthStatus.SIGNING_OUT && !session?.authenticated) {
            setAuthStatus(AuthStatus.UNAUTHENTICATED);
            postSignOut?.().then(() => {
                setLogoutIframeIsVisible(false);
            });
            return;
        }
    }, [
        session,
        postSignOut,
        setLogoutIframeIsVisible,
        displayMode,
        iframeIsVisible,
        authStatus,
        setAuthStatus,
    ]);
    return {
        signIn,
        signOut,
        startSignIn,
        authStatus,
        displayMode,
    };
};
export { useSignIn };
//# sourceMappingURL=useSignIn.js.map