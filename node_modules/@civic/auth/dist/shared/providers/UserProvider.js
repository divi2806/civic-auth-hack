"use client";
import { jsx as _jsx } from "@emotion/react/jsx-runtime";
import React, { createContext, useCallback, useEffect, useState } from "react";
import { useSession } from "../../shared/hooks/useSession.js";
import { GenericUserSession } from "../../shared/lib/UserSession.js";
import { useToken } from "../hooks/useToken.js";
const UserContext = createContext(null);
const UserProvider = ({ children, storage, user: inputUser, signOut, authStatus, signIn, displayMode, }) => {
    const { data: session, error: authError, isLoading: authLoading, } = useSession();
    const tokens = useToken();
    const [userLoading, setUserLoading] = useState(false);
    const [userError, setUserError] = useState(null);
    const [user, setUser] = useState(inputUser);
    const fetchUser = useCallback(async () => {
        if (!session?.idToken)
            return null;
        const userSession = new GenericUserSession(storage);
        return userSession.get();
    }, [session?.idToken, storage]);
    useEffect(() => {
        if (session?.idToken) {
            setUserLoading(true);
            fetchUser()
                .then((user) => {
                setUserLoading(false);
                setUser((prevUser) => {
                    // we only want to update the user if it's set - if a user is passed in, don't assume it is wrong here
                    // it could be just the fetchUser returned null for some other reason.
                    // TODO consider cleaning this up in general to avoid needing context here.
                    return user ?? prevUser;
                });
            })
                .catch((error) => {
                setUserLoading(false);
                setUserError(error);
            });
        }
        else {
            setUser(null);
        }
    }, [fetchUser, session?.idToken]);
    const isLoading = authLoading || userLoading;
    const error = authError ?? userError;
    // While we are passing a user as a prop _and_ storing it in state,
    // there is the case where the user is not set in the state yet
    // (setState is called but the rerender has not yet happened), but
    // is passed as a prop. In this case, we want to use the prop value.
    // A better solution is to avoid having multiple layers of context.
    // If the user is passed in, we just use that.
    // We should not split user state management across multiple contexts
    const userValue = user ?? inputUser;
    return (_jsx(UserContext.Provider, { value: {
            ...tokens,
            user: userValue,
            isLoading,
            error,
            signIn,
            signOut,
            authStatus,
            displayMode: displayMode || "iframe",
        }, children: children }));
};
export { UserProvider, UserContext };
//# sourceMappingURL=UserProvider.js.map