import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { renderHook } from "@testing-library/react";
import { useCookie } from "./useCookie.js";
import { act } from "react";
import * as utils from "../lib/utils.js";
vi.mock("../lib/utils.js", () => ({
    getCookie: vi.fn(),
}));
describe("useCookie", () => {
    beforeEach(() => {
        vi.useFakeTimers();
        vi.mocked(utils.getCookie).mockReturnValue("initialValue");
    });
    afterEach(() => {
        vi.useRealTimers();
    });
    it("should return initial cookie value", () => {
        const { result } = renderHook(() => useCookie("testCookie"));
        expect(result.current).toBe("initialValue");
        expect(utils.getCookie).toHaveBeenCalledWith("testCookie");
    });
    it("should update when cookie value changes", () => {
        const { result } = renderHook(() => useCookie("testCookie"));
        expect(result.current).toBe("initialValue");
        // Mock a cookie value change
        vi.mocked(utils.getCookie).mockReturnValue("newValue");
        act(() => {
            vi.advanceTimersByTime(1000);
        });
        expect(result.current).toBe("newValue");
    });
    it("should not update state if cookie value has not changed", () => {
        const { result } = renderHook(() => useCookie("testCookie"));
        const initialValue = result.current;
        // Advance timer without changing mock return value
        act(() => {
            vi.advanceTimersByTime(1000);
        });
        expect(result.current).toBe(initialValue);
        expect(utils.getCookie).toHaveBeenCalledTimes(2);
    });
    it("should clean up interval on unmount", () => {
        const clearIntervalSpy = vi.spyOn(global, "clearInterval");
        const { unmount } = renderHook(() => useCookie("testCookie"));
        unmount();
        expect(clearIntervalSpy).toHaveBeenCalled();
    });
    it("should handle transition from value to null", () => {
        const { result } = renderHook(() => useCookie("testCookie"));
        expect(result.current).toBe("initialValue");
        // Mock cookie being removed
        vi.mocked(utils.getCookie).mockReturnValue(null);
        act(() => {
            vi.advanceTimersByTime(1000);
        });
        expect(result.current).toBe(null);
    });
    it("should handle transition from null to value", () => {
        vi.mocked(utils.getCookie).mockReturnValue(null);
        const { result } = renderHook(() => useCookie("testCookie"));
        expect(result.current).toBe(null);
        // Mock cookie being set
        vi.mocked(utils.getCookie).mockReturnValue("newValue");
        act(() => {
            vi.advanceTimersByTime(1000);
        });
        expect(result.current).toBe("newValue");
    });
    it("should maintain polling interval over time", () => {
        renderHook(() => useCookie("testCookie"));
        const getCookieCalls = () => vi.mocked(utils.getCookie).mock.calls.length;
        const initialCalls = getCookieCalls();
        // Advance time and check that getCookie is called consistently
        act(() => {
            vi.advanceTimersByTime(3000);
        });
        expect(getCookieCalls()).toBe(initialCalls + 3);
    });
});
//# sourceMappingURL=useCookie.test.js.map