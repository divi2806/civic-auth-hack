import { beforeEach, describe, expect, it, vi } from "vitest";
import { useTriggerSigninOnWalletConnection } from "./useTriggerSigninOnWalletConnection.js";
import { singletonSolanaWalletAdapter } from "../lib/solana/index.js";
import { renderHook } from "@testing-library/react-hooks";
import { useUser } from "@civic/auth/react";
import { AuthStatus } from "@civic/auth";
// Mock dependencies
vi.mock("@civic/auth/react", () => ({
    useUser: vi.fn(),
}));
vi.mock("../lib/solana/index.js", () => ({
    singletonSolanaWalletAdapter: {
        registerSignInCallback: vi.fn(),
    },
}));
describe("useTriggerSigninOnWalletConnection", () => {
    // Test doubles
    let stubSignIn;
    beforeEach(() => {
        // Create stub for signIn function
        stubSignIn = vi.fn().mockResolvedValue(undefined);
        // Setup the useUser mock to return our stubSignIn
        vi.mocked(useUser).mockReturnValue({
            signIn: stubSignIn,
            signOut: vi.fn(),
            authStatus: AuthStatus.UNAUTHENTICATED,
            displayMode: "iframe",
            // Other properties the hook might need
            isLoading: false,
            user: null,
            idToken: null,
            error: null,
        });
    });
    it("should register the signIn callback with the wallet adapter", () => {
        // Render the hook
        renderHook(() => useTriggerSigninOnWalletConnection());
        // Verify that registerSignInCallback was called
        expect(singletonSolanaWalletAdapter.registerSignInCallback).toHaveBeenCalledOnce();
    });
    it("should register a callback that calls internalUserContext.signIn", async () => {
        // Render the hook
        renderHook(() => useTriggerSigninOnWalletConnection());
        // Capture the callback that was registered
        const registeredCallback = vi.mocked(singletonSolanaWalletAdapter.registerSignInCallback).mock.calls[0]?.[0];
        // Call the callback
        await registeredCallback?.();
        // Verify that signIn was called
        expect(stubSignIn).toHaveBeenCalledOnce();
    });
    it("should re-register the callback when signIn function changes", () => {
        // Initial render with the first stubSignIn
        const { rerender } = renderHook(() => useTriggerSigninOnWalletConnection());
        // Create a new stubSignIn
        const newStubSignIn = vi.fn().mockResolvedValue(undefined);
        // Update the useUser mock to return the new stubSignIn
        vi.mocked(useUser).mockReturnValue({
            signIn: newStubSignIn,
            isLoading: false,
            user: null,
            idToken: null,
            error: null,
        });
        // Re-render the hook
        rerender();
        // Verify that registerSignInCallback was called twice
        expect(singletonSolanaWalletAdapter.registerSignInCallback).toHaveBeenCalledTimes(2);
        // Verify the second call used the new signIn function
        const secondCallback = vi.mocked(singletonSolanaWalletAdapter.registerSignInCallback).mock.calls[1]?.[0];
        secondCallback?.();
        expect(newStubSignIn).toHaveBeenCalledOnce();
    });
    it("should not re-register the callback if signIn function remains the same", () => {
        // Initial render
        const { rerender } = renderHook(() => useTriggerSigninOnWalletConnection());
        // Re-render the hook without changing the signIn function
        rerender();
        // Verify that registerSignInCallback was called only once
        expect(singletonSolanaWalletAdapter.registerSignInCallback).toHaveBeenCalledTimes(1);
    });
});
//# sourceMappingURL=useTriggerSigninOnWalletConnection.test.js.map