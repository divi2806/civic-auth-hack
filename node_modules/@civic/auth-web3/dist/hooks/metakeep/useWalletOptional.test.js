import { describe, it, afterEach, expect, vi } from "vitest";
import { walletFallback } from "./useWalletOptionalFallback.js";
// Mock React's useContext to return the walletFallback directly
vi.mock("react", async () => {
    const actual = await vi.importActual("react");
    return {
        ...actual,
        useContext: () => walletFallback,
    };
});
describe("useWalletInternal behavior", () => {
    afterEach(() => {
        vi.resetModules();
    });
    it("should use fallback on server-side (no window)", async () => {
        vi.stubGlobal("window", undefined);
        const mod = await import("./useWalletOptional.js");
        expect(mod.useWalletInternal()).toEqual(walletFallback);
    });
    it("should update useWalletInternal when dynamic import succeeds", async () => {
        vi.doMock("@solana/wallet-adapter-react", () => ({
            useWallet: () => ({
                wallet: "testWallet",
            }),
        }));
        const mod = await import("./useWalletOptional.js");
        await new Promise((r) => setTimeout(r, 10)); // allow async tasks
        expect(mod.useWalletInternal().wallet).toEqual("testWallet");
    });
    it("should keep fallback when dynamic import fails", async () => {
        // Force the dynamic import to throw.
        vi.doMock("@solana/wallet-adapter-react", () => {
            throw new Error("Module not found");
        });
        const mod = await import("./useWalletOptional.js");
        await new Promise((r) => setTimeout(r, 10));
        const res = mod.useWalletInternal();
        expect(res.wallet).toEqual(walletFallback.wallet);
        await expect(res.sendTransaction).rejects.toThrow("Wallet not found");
        await expect(res.connect()).resolves.toEqual(undefined);
    });
});
//# sourceMappingURL=useWalletOptional.test.js.map