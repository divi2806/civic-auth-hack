import { describe, it, afterEach, expect, vi } from "vitest";
import { connectionFallback } from "./useConnectionOptionalFallback.js";
// Mock React's useContext to return the connectionFallback directly
vi.mock("react", async () => {
    const actual = await vi.importActual("react");
    return {
        ...actual,
        useContext: () => connectionFallback,
    };
});
describe("useConnectionInternal behavior", () => {
    afterEach(() => {
        vi.resetModules();
    });
    it("should use fallback on server-side (no window)", async () => {
        vi.stubGlobal("window", undefined);
        const mod = await import("./useConnectionOptional.js");
        expect(mod.useConnectionInternal()).toEqual(connectionFallback);
    });
    it("should update useConnectionInternal when dynamic import succeeds", async () => {
        vi.doMock("@solana/wallet-adapter-react", () => ({
            useConnection: () => ({
                connection: "testConnection",
            }),
        }));
        const mod = await import("./useConnectionOptional.js");
        await new Promise((r) => setTimeout(r, 10)); // allow async tasks
        expect(mod.useConnectionInternal().connection).toEqual("testConnection");
    });
    it("should keep fallback when dynamic import fails", async () => {
        // Force the dynamic import to throw.
        vi.doMock("@solana/wallet-adapter-react", () => {
            throw new Error("Module not found");
        });
        const mod = await import("./useConnectionOptional.js");
        await new Promise((r) => setTimeout(r, 10));
        expect(mod.useConnectionInternal()).toEqual(connectionFallback);
    });
});
//# sourceMappingURL=useConnectionOptional.test.js.map