import { describe, it, expect, vi, beforeEach } from "vitest";
import { CivicMetakeepApiClient } from "./civicApiClient.js";
// Mock user object
const mockUser = {
    email: "dummy-user@test.test",
    idToken: "mock-token",
};
// Mock fetch responses
const mockFetch = vi.fn();
describe("CivicMetakeepApiClient", () => {
    let client;
    beforeEach(() => {
        vi.stubGlobal("fetch", mockFetch);
        client = new CivicMetakeepApiClient(mockUser);
    });
    it("should initialize with default API endpoint", () => {
        expect(client.config.endpoints.wallet).toBe("https://api.civic.com/metakeep");
    });
    it("should allow overriding API endpoints", () => {
        const customConfig = {
            endpoints: { wallet: "https://custom-wallet-api.com" },
        };
        const customClient = new CivicMetakeepApiClient(mockUser, customConfig);
        expect(customClient.config.endpoints.wallet).toBe("https://custom-wallet-api.com");
    });
    describe("getWallet", () => {
        it("should make a GET request and return wallet details", async () => {
            const mockResponse = { wallet: { ethAddress: "0xMockAddress" } };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => mockResponse,
            });
            const result = await client.getWallet();
            expect(mockFetch).toHaveBeenCalledWith(`${client.config.endpoints.wallet}/wallet`, {
                headers: { Authorization: "Bearer mock-token" },
            });
            expect(result).toEqual(mockResponse);
        });
        it("should throw an error if the request fails", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: false,
                statusText: "Unauthorized",
            });
            await expect(client.getWallet()).rejects.toThrow("Failed to get wallet: Unauthorized");
        });
    });
    describe("getConfig", () => {
        it("should make a GET request and return config", async () => {
            const mockResponse = {
                metakeep: { someRandomConfig: "someRandomConfigValue" },
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => mockResponse,
            });
            const result = await client.getConfig();
            expect(mockFetch).toHaveBeenCalledWith(`${client.config.endpoints.wallet}/config`, {
                headers: { Authorization: "Bearer mock-token" },
            });
            expect(result).toEqual(mockResponse);
        });
        it("should throw an error if the request fails", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: false,
                statusText: "Unauthorized",
            });
            await expect(client.getConfig()).rejects.toThrow("Failed to get config: Unauthorized");
        });
    });
    describe("createWallet", () => {
        it("should make a POST request and return wallet details", async () => {
            const mockResponse = { wallet: { ethAddress: "0xMockAddress" } };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => mockResponse,
            });
            const result = await client.createWallet();
            expect(mockFetch).toHaveBeenCalledWith(`${client.config.endpoints.wallet}/wallet`, {
                method: "POST",
                headers: { Authorization: "Bearer mock-token" },
            });
            expect(result).toEqual(mockResponse);
        });
        it("should throw an error if the request fails", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: false,
                statusText: "Internal Server Error",
            });
            await expect(client.createWallet()).rejects.toThrow("Failed to create wallet: Internal Server Error");
        });
    });
    describe("checkWalletCreationPermission", () => {
        it("should make a GET request to the permissions endpoint", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ walletCreation: { allowed: true } }),
            });
            const result = await client.checkWalletCreationPermission();
            expect(mockFetch).toHaveBeenCalledWith(`${client.config.endpoints.wallet}/permissions`, {
                headers: { Authorization: "Bearer mock-token" },
            });
            expect(result).toBe(true);
        });
        it("should cache successful permission check results", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ allowed: true }),
            });
            await client.checkWalletCreationPermission();
            await client.checkWalletCreationPermission(); // Second call should use cached result
            // Fetch should only be called once
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });
        it("should return false for 401 unauthorized responses", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 401,
            });
            const result = await client.checkWalletCreationPermission();
            expect(result).toBe(false);
        });
        it("should return false if walletCreation allowed is false", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ walletCreation: { allowed: false } }),
            });
            const result = await client.checkWalletCreationPermission();
            expect(result).toBe(false);
        });
        it("should return true if walletCreation allowed is true", async () => {
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ walletCreation: { allowed: true } }),
            });
            const result = await client.checkWalletCreationPermission();
            expect(result).toBe(true);
        });
        it("should handle network errors and return false", async () => {
            // Mock console.error to prevent test output noise
            const consoleErrorMock = vi
                .spyOn(console, "error")
                .mockImplementation(() => { });
            // Simulate a network error
            mockFetch.mockRejectedValueOnce(new Error("Network error"));
            const result = await client.checkWalletCreationPermission();
            // Should have logged errors
            expect(consoleErrorMock).toHaveBeenCalledWith("Error checking wallet creation permission:", expect.any(Error));
            expect(consoleErrorMock).toHaveBeenCalledWith("Embedded wallet feature is disabled. To enable it, go to the Crypto Wallets section in your Civic Auth Dashboard.");
            // Should return false for network errors
            expect(result).toBe(false);
            // Restore the original console.error
            consoleErrorMock.mockRestore();
        });
    });
});
//# sourceMappingURL=civicApiClient.test.js.map