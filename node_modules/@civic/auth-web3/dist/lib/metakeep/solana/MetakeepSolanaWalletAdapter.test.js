import { describe, it, expect, vi, beforeEach, } from "vitest";
import { MetakeepSolanaWalletAdapter } from "./MetakeepSolanaWalletAdapter.js";
import MetakeepSDK from "metakeep";
import { WalletLoadError, WalletNotConnectedError, WalletNotReadyError, WalletReadyState, WalletSignTransactionError, } from "@solana/wallet-adapter-base";
import { Keypair } from "@solana/web3.js";
// Mock dependencies
vi.mock("metakeep");
const publicKey = Keypair.generate().publicKey;
// Stubbed Metakeep SDK
const stubSignedMessage = "0x123";
const mockSdk = {
    signTransaction: vi.fn(async (tx) => ({
        ...tx,
        signature: stubSignedMessage,
    })),
    signMessage: vi.fn(async () => ({
        signature: stubSignedMessage,
    })),
};
// Mock transaction
const mockTransaction = {
    serializeMessage: vi.fn(() => new Uint8Array([1, 2, 3])),
    addSignature: vi.fn(),
};
describe("MetakeepSolanaWalletAdapter", () => {
    let adapter;
    let emitSpy;
    beforeEach(() => {
        adapter = new MetakeepSolanaWalletAdapter(publicKey.toBase58(), mockSdk);
        emitSpy = vi.spyOn(adapter, "emit");
    });
    describe("connect", () => {
        it("should emit 'connect' with the public key when connected", async () => {
            await adapter.connect();
            expect(emitSpy).toHaveBeenCalledWith("connect", publicKey);
            expect(adapter.connecting).toBe(false);
        });
        it("should do nothing if already connecting", async () => {
            adapter.connecting = true;
            await adapter.connect();
            expect(emitSpy).not.toHaveBeenCalled();
        });
        it("should throw WalletNotReadyError if not in a browser context", async () => {
            vi.stubGlobal("window", undefined);
            const nodeAdapter = new MetakeepSolanaWalletAdapter(publicKey.toBase58(), mockSdk);
            await expect(nodeAdapter.connect()).rejects.toThrow(WalletNotReadyError);
        });
        it("should throw WalletNotReadyError if readyState is not 'Loadable'", async () => {
            adapter.readyState = WalletReadyState.Unsupported;
            await expect(adapter.connect()).rejects.toThrow(WalletNotReadyError);
            expect(emitSpy).toHaveBeenCalledWith("error", expect.any(WalletNotReadyError));
        });
        it("should throw WalletLoadError if an error occurs during event emission", async () => {
            vi.mocked(emitSpy).mockImplementation(() => {
                throw new Error("Emit error");
            });
            await expect(adapter.connect()).rejects.toThrow(WalletLoadError);
        });
    });
    describe("disconnect", () => {
        it("should emit 'disconnect' when disconnecting", async () => {
            adapter._connected = true;
            await adapter.disconnect();
            expect(emitSpy).toHaveBeenCalledWith("disconnect");
            expect(adapter.connecting).toBe(false);
        });
        it("should do nothing if already disconnected", async () => {
            adapter._connected = false;
            await adapter.disconnect();
            expect(emitSpy).not.toHaveBeenCalled();
            expect(adapter.connecting).toBe(false);
        });
        it("should reset connecting state", async () => {
            adapter._connected = true;
            adapter.connecting = true;
            await adapter.disconnect();
            expect(adapter.connecting).toBe(false);
        });
    });
    describe("signMessage", () => {
        it("should throw WalletNotConnectedError if not connected", async () => {
            await expect(adapter.signMessage(new Uint8Array([1, 2, 3]))).rejects.toThrow(WalletNotConnectedError);
        });
        it("should call sdk.signMessage and return a signed Uint8Array", async () => {
            adapter._connected = true;
            const message = new Uint8Array([1, 2, 3]);
            const signedMessage = await adapter.signMessage(message);
            expect(signedMessage).toEqual(Buffer.from(stubSignedMessage.slice(2), "hex"));
        });
        it("should throw WalletSignTransactionError if sdk.signMessage fails", async () => {
            adapter._connected = true;
            vi.mocked(mockSdk.signMessage).mockRejectedValue(new Error("Signing failed"));
            await expect(adapter.signMessage(new Uint8Array([1, 2, 3]))).rejects.toThrow(WalletSignTransactionError);
        });
    });
    describe("signTransaction", () => {
        beforeEach(() => {
            adapter._connected = true;
        });
        it("should throw WalletNotConnectedError if not connected", async () => {
            adapter._connected = false;
            await expect(adapter.signTransaction(mockTransaction)).rejects.toThrow(WalletNotConnectedError);
        });
        it("should call sdk.signTransaction and return a signed transaction", async () => {
            const signedTx = await adapter.signTransaction(mockTransaction);
            expect(mockTransaction.addSignature).toHaveBeenCalledWith(publicKey, Buffer.from(stubSignedMessage.slice(2), "hex"));
            expect(signedTx).toBe(mockTransaction);
        });
        it("should throw WalletSignTransactionError if sdk.signTransaction fails", async () => {
            vi.mocked(mockSdk.signTransaction).mockRejectedValue(new Error("Signing failed"));
            await expect(adapter.signTransaction(mockTransaction)).rejects.toThrow(WalletSignTransactionError);
        });
    });
    describe("supportedTransactionVersions", () => {
        it("should return a set of supported transaction versions", () => {
            expect(adapter.supportedTransactionVersions).toEqual(new Set(["0", "legacy"]));
        });
    });
    describe("signIn", () => {
        it("should throw a not implemented error", async () => {
            await expect(adapter.signIn()).rejects.toThrow(/not implemented/);
        });
    });
});
//# sourceMappingURL=MetakeepSolanaWalletAdapter.test.js.map