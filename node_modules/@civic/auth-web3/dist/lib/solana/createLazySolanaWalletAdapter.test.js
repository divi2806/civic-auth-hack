import { beforeEach, describe, expect, it, vi } from "vitest";
import { createLazySolanaWalletAdapter, } from "./createLazySolanaWalletAdapter.js";
import { web3Events } from "../Web3Client.js";
import { Keypair, PublicKey } from "@solana/web3.js";
import { createLazyProxy, } from "../lazy/LazyProxy.js";
vi.mock("../lazy/LazyProxy.js");
const createStubLazyProxy = () => ({
    ready: vi.fn().mockReturnValue(false),
    getImplementation: vi.fn().mockReturnValue(null),
    setImplementation: vi.fn(),
    connect: vi.fn(),
    registerSignInCallback: vi.fn(),
});
// Setup stub web3 client
const stubWeb3Client = {
    solana: {
        wallet: {
            connect: vi.fn().mockResolvedValue(undefined),
        },
        address: Keypair.generate().publicKey,
    },
};
describe("createLazySolanaWalletAdapter", () => {
    let walletAdapter;
    let stubSignInCallback;
    beforeEach(() => {
        vi.mocked(createLazyProxy).mockImplementation(createStubLazyProxy);
        // Setup stub for sign-in callback
        stubSignInCallback = vi.fn().mockResolvedValue(undefined);
        // Create the adapter
        walletAdapter = createLazySolanaWalletAdapter();
    });
    it("should create a lazy proxy with the correct methods", () => {
        // Verify createLazyProxy was called with expected arguments
        expect(createLazyProxy).toHaveBeenCalledWith(["connect"]);
        // Verify methods exist
        expect(typeof walletAdapter.connect).toBe("function");
        expect(typeof walletAdapter.registerSignInCallback).toBe("function");
    });
    it("should set up a web3ClientReady event listener on first connect call", () => {
        // Set up spy on the web3Events.on method
        const onSpy = vi.spyOn(web3Events, "on");
        // Call connect
        walletAdapter.connect();
        // Verify the event subscription
        expect(onSpy).toHaveBeenCalledWith("web3ClientReady", expect.any(Function));
    });
    it("should only set up the event listener once even when connect is called multiple times", () => {
        // Set up spy on the web3Events.on method
        const onSpy = vi.spyOn(web3Events, "on");
        // Call connect multiple times
        walletAdapter.connect();
        walletAdapter.connect();
        // Verify the event listener was set up only once
        expect(onSpy).toHaveBeenCalledOnce();
    });
    it("should delegate to underlying implementation when wallet is ready", async () => {
        // Create stub for the wallet implementation
        const stubConnectMethod = vi
            .fn()
            .mockResolvedValue({ publicKey: Keypair.generate().publicKey });
        const stubWalletImpl = {
            connect: stubConnectMethod,
        };
        // Configure the proxy to return "ready" and the stubbed implementation
        vi.mocked(walletAdapter.ready).mockReturnValue(true);
        vi.mocked(walletAdapter.getImplementation).mockReturnValue(stubWalletImpl);
        // Call connect
        await walletAdapter.connect();
        // Verify that it delegated to the implementation
        expect(stubConnectMethod).toHaveBeenCalledOnce();
    });
    it("should trigger sign-in when connect is called and a callback is registered", () => {
        // Register sign-in callback
        walletAdapter.registerSignInCallback(stubSignInCallback);
        // Call connect
        walletAdapter.connect();
        // Verify the sign-in callback was called
        expect(stubSignInCallback).toHaveBeenCalledTimes(1);
    });
    it("should handle multiple connect calls while sign-in is in progress", () => {
        // Create a fake sign-in implementation with delay
        const fakeSignInWithDelay = vi.fn().mockImplementation(() => new Promise((resolve) => {
            setTimeout(resolve, 50);
        }));
        walletAdapter.registerSignInCallback(fakeSignInWithDelay);
        // Call connect multiple times
        walletAdapter.connect();
        walletAdapter.connect();
        // Sign-in should only be called once
        expect(fakeSignInWithDelay).toHaveBeenCalledTimes(1);
    });
    it("should handle errors during sign-in", async () => {
        const signInError = new Error("Sign-in failed");
        const stubSignInWithError = vi.fn().mockRejectedValue(signInError);
        walletAdapter.registerSignInCallback(stubSignInWithError);
        // Connect should throw the sign-in error
        await expect(walletAdapter.connect()).rejects.toThrow(signInError);
    });
    it("should automatically trigger sign-in for pending connect promises when registering a callback", () => {
        // Call connect first
        walletAdapter.connect();
        // Then register sign-in callback
        walletAdapter.registerSignInCallback(stubSignInCallback);
        // Sign-in should be triggered automatically
        expect(stubSignInCallback).toHaveBeenCalledOnce();
    });
    it("should not trigger sign-in automatically if wallet is already ready", () => {
        // Configure proxy to return ready
        vi.mocked(walletAdapter.ready).mockReturnValue(true);
        // Call connect first
        walletAdapter.connect();
        // Then register sign-in callback
        walletAdapter.registerSignInCallback(stubSignInCallback);
        // Sign-in should not be triggered
        expect(stubSignInCallback).not.toHaveBeenCalled();
    });
    it("should reject all pending promises if sign-in fails after registering callback", async () => {
        const signInError = new Error("Sign-in failed");
        const stubSignInWithError = vi.fn().mockRejectedValue(signInError);
        // Call connect first
        const connectPromise = walletAdapter.connect();
        // Then register sign-in callback that will fail
        walletAdapter.registerSignInCallback(stubSignInWithError);
        // Connect promise should reject with the sign-in error
        await expect(connectPromise).rejects.toThrow(signInError);
    });
    it("should reject all pending promises if sign-in fails with a non-Error object", async () => {
        const signInError = "Sign-in failed";
        const stubSignInWithError = vi.fn().mockRejectedValue(signInError);
        // Call connect first
        const connectPromise = walletAdapter.connect();
        // Then register sign-in callback that will fail
        walletAdapter.registerSignInCallback(stubSignInWithError);
        // Connect promise should reject with the sign-in error
        await expect(connectPromise).rejects.toThrow(signInError);
    });
    it("should reject all pending promises if the connection process fails", async () => {
        // Setup: Make ready return true to trigger the connection path
        vi.mocked(walletAdapter.ready).mockReturnValue(true);
        // Create a specific connection error
        const connectionError = new Error("Connection failed");
        // Make the wallet's connect method throw an error
        stubWeb3Client.solana.wallet.connect = vi
            .fn()
            .mockRejectedValue(connectionError);
        // Call connect multiple times to queue up promises
        const promise1 = walletAdapter.connect();
        const promise2 = walletAdapter.connect();
        // Emit the event to trigger the connection process
        web3Events.emit("web3ClientReady", stubWeb3Client);
        // All promises should be rejected with the connection error
        await expect(promise1).rejects.toThrow(connectionError);
        await expect(promise2).rejects.toThrow(connectionError);
    });
    it("should reject all pending promises if the connection process fails with a non-Error object", async () => {
        // Setup: Make ready return true to trigger the connection path
        vi.mocked(walletAdapter.ready).mockReturnValue(true);
        // Create a specific connection error as a stirng
        const connectionError = "Connection failed";
        // Make the wallet's connect method throw an error
        stubWeb3Client.solana.wallet.connect = vi
            .fn()
            .mockRejectedValue(connectionError);
        // Call connect multiple times to queue up promises
        const promise1 = walletAdapter.connect();
        const promise2 = walletAdapter.connect();
        // Emit the event to trigger the connection process
        web3Events.emit("web3ClientReady", stubWeb3Client);
        // All promises should be rejected with the connection error
        await expect(promise1).rejects.toThrow(connectionError);
        await expect(promise2).rejects.toThrow(connectionError);
    });
    it("should resolve connect promises when web3ClientReady event fires", async () => {
        // Call connect and store the promise
        const connectPromise = walletAdapter.connect();
        // simulate logging in (setting the proxy implementation)
        vi.mocked(walletAdapter.ready).mockReturnValue(true);
        // Emit the event with the stub web3 client
        web3Events.emit("web3ClientReady", stubWeb3Client);
        // Now the connect promise should resolve
        const result = await connectPromise;
        // Verify we got the expected result
        expect(result).toEqual({
            publicKey: new PublicKey(stubWeb3Client.solana.address),
        });
    });
    it("should resolve multiple connect promises when web3ClientReady event fires", async () => {
        // Call connect multiple times
        const promise1 = walletAdapter.connect();
        const promise2 = walletAdapter.connect();
        // simulate logging in (setting the proxy implementation)
        vi.mocked(walletAdapter.ready).mockReturnValue(true);
        // Emit the event with the stub web3 client
        web3Events.emit("web3ClientReady", stubWeb3Client);
        // All promises should resolve
        const [result1, result2] = await Promise.all([promise1, promise2]);
        // Verify both promises resolved with the expected result
        expect(result1).toEqual({
            publicKey: new PublicKey(stubWeb3Client.solana.address),
        });
        expect(result2).toEqual({
            publicKey: new PublicKey(stubWeb3Client.solana.address),
        });
    });
});
//# sourceMappingURL=createLazySolanaWalletAdapter.test.js.map