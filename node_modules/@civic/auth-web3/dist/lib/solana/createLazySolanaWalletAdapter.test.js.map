{"version":3,"file":"createLazySolanaWalletAdapter.test.js","sourceRoot":"","sources":["../../../src/lib/solana/createLazySolanaWalletAdapter.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { beforeEach, describe, expect, it, vi } from \"vitest\";\nimport {\n  createLazySolanaWalletAdapter,\n  type SignInTrigger,\n} from \"./createLazySolanaWalletAdapter.js\";\nimport { type Web3Client, web3Events } from \"../Web3Client.js\";\nimport { Keypair, PublicKey } from \"@solana/web3.js\";\nimport {\n  createLazyProxy,\n  type EventMap,\n  type EventRegistrar,\n  type LazyProxy,\n} from \"../lazy/LazyProxy.js\";\nimport type { CivicWallet } from \"./walletAdapter/window.js\";\n\nvi.mock(\"../lazy/LazyProxy.js\");\n\nconst createStubLazyProxy = <\n  TUnderlying extends EventRegistrar<TEventMap>,\n  TEventMap extends EventMap,\n>(): LazyProxy<TUnderlying> =>\n  ({\n    ready: vi.fn().mockReturnValue(false),\n    getImplementation: vi.fn().mockReturnValue(null),\n    setImplementation: vi.fn(),\n    connect: vi.fn(),\n    registerSignInCallback: vi.fn(),\n  }) as unknown as LazyProxy<TUnderlying>;\n\n// Setup stub web3 client\nconst stubWeb3Client = {\n  solana: {\n    wallet: {\n      connect: vi.fn().mockResolvedValue(undefined),\n    },\n    address: Keypair.generate().publicKey,\n  },\n} as unknown as Web3Client;\n\ndescribe(\"createLazySolanaWalletAdapter\", () => {\n  let walletAdapter: LazyProxy<CivicWallet> & SignInTrigger;\n  let stubSignInCallback: () => Promise<void>;\n\n  beforeEach(() => {\n    vi.mocked(createLazyProxy).mockImplementation(createStubLazyProxy);\n\n    // Setup stub for sign-in callback\n    stubSignInCallback = vi.fn().mockResolvedValue(undefined);\n\n    // Create the adapter\n    walletAdapter = createLazySolanaWalletAdapter();\n  });\n\n  it(\"should create a lazy proxy with the correct methods\", () => {\n    // Verify createLazyProxy was called with expected arguments\n    expect(createLazyProxy).toHaveBeenCalledWith([\"connect\"]);\n\n    // Verify methods exist\n    expect(typeof walletAdapter.connect).toBe(\"function\");\n    expect(typeof walletAdapter.registerSignInCallback).toBe(\"function\");\n  });\n\n  it(\"should set up a web3ClientReady event listener on first connect call\", () => {\n    // Set up spy on the web3Events.on method\n    const onSpy = vi.spyOn(web3Events, \"on\");\n\n    // Call connect\n    walletAdapter.connect();\n\n    // Verify the event subscription\n    expect(onSpy).toHaveBeenCalledWith(\"web3ClientReady\", expect.any(Function));\n  });\n\n  it(\"should only set up the event listener once even when connect is called multiple times\", () => {\n    // Set up spy on the web3Events.on method\n    const onSpy = vi.spyOn(web3Events, \"on\");\n\n    // Call connect multiple times\n    walletAdapter.connect();\n    walletAdapter.connect();\n\n    // Verify the event listener was set up only once\n    expect(onSpy).toHaveBeenCalledOnce();\n  });\n\n  it(\"should delegate to underlying implementation when wallet is ready\", async () => {\n    // Create stub for the wallet implementation\n    const stubConnectMethod = vi\n      .fn()\n      .mockResolvedValue({ publicKey: Keypair.generate().publicKey });\n    const stubWalletImpl = {\n      connect: stubConnectMethod,\n    } as unknown as CivicWallet;\n\n    // Configure the proxy to return \"ready\" and the stubbed implementation\n    vi.mocked(walletAdapter.ready).mockReturnValue(true);\n    vi.mocked(walletAdapter.getImplementation).mockReturnValue(stubWalletImpl);\n\n    // Call connect\n    await walletAdapter.connect();\n\n    // Verify that it delegated to the implementation\n    expect(stubConnectMethod).toHaveBeenCalledOnce();\n  });\n\n  it(\"should trigger sign-in when connect is called and a callback is registered\", () => {\n    // Register sign-in callback\n    walletAdapter.registerSignInCallback(stubSignInCallback);\n\n    // Call connect\n    walletAdapter.connect();\n\n    // Verify the sign-in callback was called\n    expect(stubSignInCallback).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should handle multiple connect calls while sign-in is in progress\", () => {\n    // Create a fake sign-in implementation with delay\n    const fakeSignInWithDelay = vi.fn().mockImplementation(\n      () =>\n        new Promise((resolve) => {\n          setTimeout(resolve, 50);\n        }),\n    );\n\n    walletAdapter.registerSignInCallback(fakeSignInWithDelay);\n\n    // Call connect multiple times\n    walletAdapter.connect();\n    walletAdapter.connect();\n\n    // Sign-in should only be called once\n    expect(fakeSignInWithDelay).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should handle errors during sign-in\", async () => {\n    const signInError = new Error(\"Sign-in failed\");\n    const stubSignInWithError = vi.fn().mockRejectedValue(signInError);\n\n    walletAdapter.registerSignInCallback(stubSignInWithError);\n\n    // Connect should throw the sign-in error\n    await expect(walletAdapter.connect()).rejects.toThrow(signInError);\n  });\n\n  it(\"should automatically trigger sign-in for pending connect promises when registering a callback\", () => {\n    // Call connect first\n    walletAdapter.connect();\n\n    // Then register sign-in callback\n    walletAdapter.registerSignInCallback(stubSignInCallback);\n\n    // Sign-in should be triggered automatically\n    expect(stubSignInCallback).toHaveBeenCalledOnce();\n  });\n\n  it(\"should not trigger sign-in automatically if wallet is already ready\", () => {\n    // Configure proxy to return ready\n    vi.mocked(walletAdapter.ready).mockReturnValue(true);\n\n    // Call connect first\n    walletAdapter.connect();\n\n    // Then register sign-in callback\n    walletAdapter.registerSignInCallback(stubSignInCallback);\n\n    // Sign-in should not be triggered\n    expect(stubSignInCallback).not.toHaveBeenCalled();\n  });\n\n  it(\"should reject all pending promises if sign-in fails after registering callback\", async () => {\n    const signInError = new Error(\"Sign-in failed\");\n    const stubSignInWithError = vi.fn().mockRejectedValue(signInError);\n\n    // Call connect first\n    const connectPromise = walletAdapter.connect();\n\n    // Then register sign-in callback that will fail\n    walletAdapter.registerSignInCallback(stubSignInWithError);\n\n    // Connect promise should reject with the sign-in error\n    await expect(connectPromise).rejects.toThrow(signInError);\n  });\n\n  it(\"should reject all pending promises if sign-in fails with a non-Error object\", async () => {\n    const signInError = \"Sign-in failed\";\n    const stubSignInWithError = vi.fn().mockRejectedValue(signInError);\n\n    // Call connect first\n    const connectPromise = walletAdapter.connect();\n\n    // Then register sign-in callback that will fail\n    walletAdapter.registerSignInCallback(stubSignInWithError);\n\n    // Connect promise should reject with the sign-in error\n    await expect(connectPromise).rejects.toThrow(signInError);\n  });\n\n  it(\"should reject all pending promises if the connection process fails\", async () => {\n    // Setup: Make ready return true to trigger the connection path\n    vi.mocked(walletAdapter.ready).mockReturnValue(true);\n\n    // Create a specific connection error\n    const connectionError = new Error(\"Connection failed\");\n\n    // Make the wallet's connect method throw an error\n    stubWeb3Client.solana.wallet.connect = vi\n      .fn()\n      .mockRejectedValue(connectionError);\n\n    // Call connect multiple times to queue up promises\n    const promise1 = walletAdapter.connect();\n    const promise2 = walletAdapter.connect();\n\n    // Emit the event to trigger the connection process\n    web3Events.emit(\"web3ClientReady\", stubWeb3Client);\n\n    // All promises should be rejected with the connection error\n    await expect(promise1).rejects.toThrow(connectionError);\n    await expect(promise2).rejects.toThrow(connectionError);\n  });\n\n  it(\"should reject all pending promises if the connection process fails with a non-Error object\", async () => {\n    // Setup: Make ready return true to trigger the connection path\n    vi.mocked(walletAdapter.ready).mockReturnValue(true);\n\n    // Create a specific connection error as a stirng\n    const connectionError = \"Connection failed\";\n\n    // Make the wallet's connect method throw an error\n    stubWeb3Client.solana.wallet.connect = vi\n      .fn()\n      .mockRejectedValue(connectionError);\n\n    // Call connect multiple times to queue up promises\n    const promise1 = walletAdapter.connect();\n    const promise2 = walletAdapter.connect();\n\n    // Emit the event to trigger the connection process\n    web3Events.emit(\"web3ClientReady\", stubWeb3Client);\n\n    // All promises should be rejected with the connection error\n    await expect(promise1).rejects.toThrow(connectionError);\n    await expect(promise2).rejects.toThrow(connectionError);\n  });\n\n  it(\"should resolve connect promises when web3ClientReady event fires\", async () => {\n    // Call connect and store the promise\n    const connectPromise = walletAdapter.connect();\n\n    // simulate logging in (setting the proxy implementation)\n    vi.mocked(walletAdapter.ready).mockReturnValue(true);\n\n    // Emit the event with the stub web3 client\n    web3Events.emit(\"web3ClientReady\", stubWeb3Client);\n\n    // Now the connect promise should resolve\n    const result = await connectPromise;\n\n    // Verify we got the expected result\n    expect(result).toEqual({\n      publicKey: new PublicKey(stubWeb3Client.solana.address),\n    });\n  });\n\n  it(\"should resolve multiple connect promises when web3ClientReady event fires\", async () => {\n    // Call connect multiple times\n    const promise1 = walletAdapter.connect();\n    const promise2 = walletAdapter.connect();\n\n    // simulate logging in (setting the proxy implementation)\n    vi.mocked(walletAdapter.ready).mockReturnValue(true);\n\n    // Emit the event with the stub web3 client\n    web3Events.emit(\"web3ClientReady\", stubWeb3Client);\n\n    // All promises should resolve\n    const [result1, result2] = await Promise.all([promise1, promise2]);\n\n    // Verify both promises resolved with the expected result\n    expect(result1).toEqual({\n      publicKey: new PublicKey(stubWeb3Client.solana.address),\n    });\n    expect(result2).toEqual({\n      publicKey: new PublicKey(stubWeb3Client.solana.address),\n    });\n  });\n});\n"]}