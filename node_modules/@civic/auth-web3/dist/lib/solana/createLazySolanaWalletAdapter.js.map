{"version":3,"file":"createLazySolanaWalletAdapter.js","sourceRoot":"","sources":["../../../src/lib/solana/createLazySolanaWalletAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// A type representing an object that can trigger the sign-in process\n// This is added to the CivicWallet interface to allow registering a\n// callback that opens the Civic Auth login window on connect.\nimport { web3Events } from \"../Web3Client.js\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { createLazyProxy, type LazyProxy } from \"../lazy/LazyProxy.js\";\nimport type { CivicWallet } from \"./walletAdapter/window.js\";\n\nexport type SignInTrigger = {\n  registerSignInCallback: (callback: () => Promise<void>) => void;\n};\n// The same as CivicWalletEvent, but using a 'Type' so that typescript automatically\n// interprets it as inheriting Record<string, unknown> instead of a specific type.\nexport type CivicWalletEventType = {\n  connect(...args: unknown[]): unknown;\n  disconnect(...args: unknown[]): unknown;\n  accountChanged(...args: unknown[]): unknown;\n};\n// Type definitions for the connect result and promise handling\ntype ConnectResult = { publicKey: PublicKey };\ntype ConnectPromise = {\n  resolve: (value: ConnectResult | PromiseLike<ConnectResult>) => void;\n  reject: (reason?: Error) => void;\n};\nexport const createLazySolanaWalletAdapter = (): LazyProxy<CivicWallet> &\n  SignInTrigger => {\n  // Queue of promises waiting to be resolved when the wallet connects\n  const connectPromises: ConnectPromise[] = [];\n\n  // Callback that will be called to trigger sign-in when needed\n  let signInCallback: (() => Promise<void>) | null = null;\n\n  // Flag to prevent setting up multiple event listeners\n  let hasSetupEventListener = false;\n\n  // Flag to track if a sign-in operation is currently in progress\n  let isConnecting = false;\n\n  // Sets up the event listener for web3ClientReady event\n  // This happens only once to prevent duplicate listeners\n  const setupEventListener = () => {\n    // Skip if already set up\n    if (hasSetupEventListener) return;\n    hasSetupEventListener = true;\n\n    // Listen for the web3ClientReady event which fires when the wallet is initialized\n    web3Events.on(\"web3ClientReady\", async (web3Client) => {\n      try {\n        if (proxy.ready()) {\n          // CASE 1: The wallet is ready (implementation exists)\n          // Call connect on the underlying implementation to ensure it's connected\n          await web3Client.solana.wallet.connect();\n\n          // Get the wallet's public key\n          const publicKey = new PublicKey(web3Client.solana.address);\n\n          // Resolve all waiting promises with the wallet's public key\n          const result = { publicKey };\n          while (connectPromises.length > 0) {\n            const promise = connectPromises.shift();\n            if (promise) promise.resolve(result);\n          }\n          // Reset connecting flag since we're done\n          isConnecting = false;\n        } else {\n          // CASE 2: The wallet is not ready, but we have pending connect promises\n          // This means someone called connect() before the wallet was ready\n          if (connectPromises.length > 0 && signInCallback) {\n            // Set connecting flag to prevent duplicate sign-in attempts\n            isConnecting = true;\n            // Trigger the sign-in flow\n            await signInCallback();\n            // We don't resolve promises here - wait for next web3ClientReady event\n            // that will happen after sign-in completes and the wallet is initialized\n          }\n        }\n      } catch (error) {\n        // Error during connection process - reject all pending promises\n        while (connectPromises.length > 0) {\n          // remove the promise from the queue\n          const promise = connectPromises.shift();\n          if (promise)\n            promise.reject(\n              error instanceof Error ? error : new Error(String(error)),\n            );\n        }\n        isConnecting = false;\n      }\n    });\n  };\n\n  // Create the lazy proxy instance implementing both the CivicWallet and SignInTrigger interfaces\n  const proxy: LazyProxy<CivicWallet> & SignInTrigger = createLazyProxy<\n    CivicWallet,\n    CivicWalletEventType\n  >([\"connect\"]) as LazyProxy<CivicWallet> & SignInTrigger;\n\n  // Add a connect method to the proxy\n  // This will be called before the real wallet implementation exists\n  proxy[\"connect\"] = async (args) => {\n    // Make sure our event listener is set up\n    setupEventListener();\n\n    // CASE 1: If the real wallet implementation exists, delegate to it\n    if (proxy.ready()) {\n      const underlying = proxy.getImplementation();\n      if (underlying) {\n        return underlying.connect(args);\n      }\n    }\n\n    // CASE 2: A sign-in is already in progress, just wait for it to complete\n    if (isConnecting) {\n      return new Promise<ConnectResult>((resolve, reject) => {\n        connectPromises.push({ resolve, reject });\n      });\n    }\n\n    // CASE 3: Need to start a new sign-in flow\n    if (signInCallback) {\n      isConnecting = true;\n      try {\n        // Trigger the sign-in process\n        await signInCallback();\n        // Return a promise that will be resolved when web3ClientReady fires\n        // after the sign-in completes\n        return new Promise<ConnectResult>((resolve, reject) => {\n          connectPromises.push({ resolve, reject });\n        });\n      } catch (error) {\n        // If sign-in fails, reset connecting flag and propagate error\n        isConnecting = false;\n        throw error;\n      }\n    } else {\n      // CASE 4: No sign-in callback registered yet, just queue the promise\n      // This handles the race condition where connect is called before\n      // registerSignInCallback\n      return new Promise<ConnectResult>((resolve, reject) => {\n        connectPromises.push({ resolve, reject });\n      });\n    }\n  };\n\n  // Add method to register the sign-in callback\n  // This will be called from the React layer to provide the signIn function\n  proxy[\"registerSignInCallback\"] = (callback) => {\n    signInCallback = callback;\n    setupEventListener(); // Ensure event listener is set up\n\n    // If there are pending connect calls and no sign-in is in progress,\n    // we should trigger the sign-in now\n    if (connectPromises.length > 0 && !isConnecting && !proxy.ready()) {\n      isConnecting = true;\n      // Call the callback directly - it's already async so it won't block\n      callback().catch((error) => {\n        // Sign-in failed - reject all pending promises\n        isConnecting = false;\n        while (connectPromises.length > 0) {\n          const promise = connectPromises.shift();\n          if (promise) {\n            promise.reject(\n              error instanceof Error ? error : new Error(String(error)),\n            );\n          }\n        }\n      });\n    }\n  };\n\n  return proxy;\n};\n"]}