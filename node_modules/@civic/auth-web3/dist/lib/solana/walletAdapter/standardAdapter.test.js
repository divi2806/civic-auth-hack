import { beforeEach, describe, expect, it, vi } from "vitest";
import { MetakeepWalletStandardAdapter } from "./standardAdapter.js";
import { WalletNotConnectedError } from "@solana/wallet-adapter-base";
import { Transaction as LegacyTransaction, PublicKey, VersionedTransaction, Keypair, } from "@solana/web3.js";
describe("MetakeepWalletStandardAdapter", () => {
    // Test doubles
    let stubDelegate;
    let stubConnection;
    let standardAdapter;
    let dummyPublicKey;
    beforeEach(() => {
        // Create dummy PublicKey
        dummyPublicKey = Keypair.generate().publicKey;
        // Create stub for delegate wallet adapter
        stubDelegate = {
            publicKey: dummyPublicKey,
            connected: true,
            connect: vi.fn().mockResolvedValue(undefined),
            disconnect: vi.fn().mockResolvedValue(undefined),
            signTransaction: vi.fn().mockImplementation((tx) => Promise.resolve(tx)),
            signAllTransactions: vi.fn(),
            signMessage: vi.fn().mockResolvedValue(new Uint8Array([1, 2, 3])),
            signIn: vi.fn().mockResolvedValue({ accounts: [] }),
            on: vi.fn(),
            off: vi.fn(),
        };
        // Create stub for Solana connection
        stubConnection = {
            sendTransaction: vi.fn().mockResolvedValue("test-signature"),
        };
        // Create the adapter under test
        standardAdapter = new MetakeepWalletStandardAdapter(stubDelegate, stubConnection);
    });
    it("should return the delegate's publicKey when connected", () => {
        expect(standardAdapter.publicKey).toBe(dummyPublicKey);
    });
    it("should return null for publicKey when not connected", () => {
        // the stub delegate lets us manually change its connected status - work around the typescript complaint by casting
        stubDelegate.connected = false;
        expect(standardAdapter.publicKey).toBeNull();
    });
    it("should delegate connect and return the publicKey", async () => {
        const result = await standardAdapter.connect();
        expect(stubDelegate.connect).toHaveBeenCalledOnce();
        expect(result).toEqual({ publicKey: dummyPublicKey });
    });
    it("should delegate disconnect", async () => {
        await standardAdapter.disconnect();
        expect(stubDelegate.disconnect).toHaveBeenCalledOnce();
    });
    it("should sign and send a legacy transaction", async () => {
        // Create a stub for a legacy transaction
        const stubTransaction = {
            serialize: () => new Uint8Array([1, 2, 3]),
        };
        // Sign and send transaction
        const result = await standardAdapter.signAndSendTransaction(stubTransaction);
        // Verify delegate signed the transaction
        expect(stubDelegate.signTransaction).toHaveBeenCalledWith(stubTransaction);
        // Verify connection sent the transaction
        expect(stubConnection.sendTransaction).toHaveBeenCalled();
        // Verify correct result
        expect(result).toEqual({ signature: "test-signature" });
    });
    it("should sign and send a versioned transaction", async () => {
        // Create a stub for a versioned transaction
        const stubVersionedTx = {
            serialize: () => new Uint8Array([1, 2, 3]),
        };
        // Sign and send transaction
        const result = await standardAdapter.signAndSendTransaction(stubVersionedTx);
        // Verify delegate signed the transaction
        expect(stubDelegate.signTransaction).toHaveBeenCalledWith(stubVersionedTx);
        // Verify connection sent the transaction (with different arguments)
        expect(stubConnection.sendTransaction).toHaveBeenCalled();
        // Verify correct result
        expect(result).toEqual({ signature: "test-signature" });
    });
    it("should throw WalletNotConnectedError when not connected", async () => {
        // the stub delegate lets us manually change its connected status - work around the typescript complaint by casting
        stubDelegate.connected = false;
        const stubTransaction = {};
        await expect(standardAdapter.signAndSendTransaction(stubTransaction)).rejects.toThrow(WalletNotConnectedError);
    });
    it("should delegate signTransaction", async () => {
        const stubTransaction = {};
        await standardAdapter.signTransaction(stubTransaction);
        expect(stubDelegate.signTransaction).toHaveBeenCalledWith(stubTransaction);
    });
    it("should delegate signAllTransactions", async () => {
        const stubTransactions = [{}, {}];
        // Set up the delegate to return specific results for each transaction
        stubDelegate.signTransaction = vi
            .fn()
            .mockResolvedValueOnce("signed1")
            .mockResolvedValueOnce("signed2");
        const result = await standardAdapter.signAllTransactions(stubTransactions);
        // Verify each transaction was signed
        expect(stubDelegate.signTransaction).toHaveBeenCalledTimes(2);
        expect(result).toEqual(["signed1", "signed2"]);
    });
    it("should delegate signMessage and wrap the result", async () => {
        const message = new Uint8Array([4, 5, 6]);
        const result = await standardAdapter.signMessage(message);
        expect(stubDelegate.signMessage).toHaveBeenCalledWith(message);
        expect(result).toEqual({ signature: new Uint8Array([1, 2, 3]) });
    });
    it("should delegate signIn", async () => {
        const input = { domain: "test.com" };
        await standardAdapter.signIn(input);
        expect(stubDelegate.signIn).toHaveBeenCalledWith(input);
    });
    it("should forward connect and disconnect events to delegate", () => {
        const listener = vi.fn();
        const context = {};
        standardAdapter.on("connect", listener, context);
        standardAdapter.on("disconnect", listener, context);
        expect(stubDelegate.on).toHaveBeenCalledTimes(2);
        expect(stubDelegate.on).toHaveBeenCalledWith("connect", listener, context);
        expect(stubDelegate.on).toHaveBeenCalledWith("disconnect", listener, context);
    });
    it("should not forward accountChanged events to delegate", () => {
        const listener = vi.fn();
        standardAdapter.on("accountChanged", listener);
        // Verify no delegation for accountChanged
        expect(stubDelegate.on).not.toHaveBeenCalledWith("accountChanged", listener);
    });
    it("should forward connect and disconnect event removals to delegate", () => {
        const listener = vi.fn();
        const context = {};
        standardAdapter.off("connect", listener, context);
        standardAdapter.off("disconnect", listener, context);
        expect(stubDelegate.off).toHaveBeenCalledTimes(2);
        expect(stubDelegate.off).toHaveBeenCalledWith("connect", listener, context);
        expect(stubDelegate.off).toHaveBeenCalledWith("disconnect", listener, context);
    });
    it("should not forward accountChanged event removals to delegate", () => {
        const listener = vi.fn();
        standardAdapter.off("accountChanged", listener);
        // Verify no delegation for accountChanged
        expect(stubDelegate.off).not.toHaveBeenCalledWith("accountChanged", listener);
    });
    it("should use removeListener as an alias for off", () => {
        const listener = vi.fn();
        const offSpy = vi.spyOn(standardAdapter, "off");
        standardAdapter.removeListener("connect", listener);
        expect(offSpy).toHaveBeenCalledWith("connect", listener, undefined);
    });
});
//# sourceMappingURL=standardAdapter.test.js.map