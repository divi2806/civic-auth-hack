import { SolanaSignAndSendTransaction, SolanaSignIn, SolanaSignMessage, SolanaSignTransaction, } from "@solana/wallet-standard-features";
import { VersionedTransaction } from "@solana/web3.js";
import { StandardConnect, StandardDisconnect, StandardEvents, } from "@wallet-standard/features";
import bs58 from "bs58";
import { CivicWalletAccount } from "./account.js";
import { isSolanaChain, SOLANA_CHAINS } from "./solana.js";
import { bytesEqual } from "./util.js";
import { ICON } from "../../walletUtils.js";
import { withAnalytics } from "../../analytics/index.js";
export const CivicWalletNamespace = "civicWallet:";
export class CivicWalletAdapter {
    #listeners = {};
    #version = "1.0.0";
    #name = "Civic Wallet";
    #icon = ICON;
    #account = null;
    #civicWallet;
    get version() {
        return this.#version;
    }
    get name() {
        return this.#name;
    }
    get icon() {
        return this.#icon;
    }
    get chains() {
        return SOLANA_CHAINS.slice();
    }
    get features() {
        return {
            [StandardConnect]: {
                version: "1.0.0",
                connect: this.#connect,
            },
            [StandardDisconnect]: {
                version: "1.0.0",
                disconnect: this.#disconnect,
            },
            [StandardEvents]: {
                version: "1.0.0",
                on: this.#on,
            },
            [SolanaSignAndSendTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signAndSendTransaction: this.#signAndSendTransaction,
            },
            [SolanaSignTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signTransaction: this.#signTransaction,
            },
            [SolanaSignMessage]: {
                version: "1.0.0",
                signMessage: this.#signMessage,
            },
            [SolanaSignIn]: {
                version: "1.0.0",
                signIn: this.#signIn,
            },
            [CivicWalletNamespace]: {
                civicWallet: this.#civicWallet,
            },
        };
    }
    get accounts() {
        return this.#account ? [this.#account] : [];
    }
    constructor(civicWallet) {
        if (new.target === CivicWalletAdapter) {
            Object.freeze(this);
        }
        this.#civicWallet = civicWallet;
        civicWallet.on("connect", this.#connected, this);
        civicWallet.on("disconnect", this.#disconnected, this);
        civicWallet.on("accountChanged", this.#reconnected, this);
        this.#connected();
    }
    #on = (event, listener) => {
        if (this.#listeners[event]) {
            this.#listeners[event].push(listener);
        }
        else {
            this.#listeners[event] = [listener];
        }
        return () => this.#off(event, listener);
    };
    #emit(event, ...args) {
        // eslint-disable-next-line prefer-spread
        this.#listeners[event]?.forEach((listener) => listener.apply(null, args));
    }
    #off(event, listener) {
        this.#listeners[event] = this.#listeners[event]?.filter((existingListener) => listener !== existingListener);
    }
    #connected = () => {
        const address = this.#civicWallet.publicKey?.toBase58();
        if (address) {
            const publicKey = this.#civicWallet.publicKey.toBytes();
            const account = this.#account;
            if (!account ||
                account.address !== address ||
                !bytesEqual(account.publicKey, publicKey)) {
                this.#account = new CivicWalletAccount({ address, publicKey });
                this.#emit("change", { accounts: this.accounts });
            }
        }
    };
    #disconnected = () => {
        if (this.#account) {
            this.#account = null;
            this.#emit("change", { accounts: this.accounts });
        }
    };
    #reconnected = () => {
        if (this.#civicWallet.publicKey) {
            this.#connected();
        }
        else {
            this.#disconnected();
        }
    };
    #connect = async ({ silent } = {}) => {
        if (!this.#account) {
            await this.#civicWallet.connect(silent ? { onlyIfTrusted: true } : undefined);
        }
        this.#connected();
        return { accounts: this.accounts };
    };
    #disconnect = async () => {
        await this.#civicWallet.disconnect();
    };
    #signAndSendTransaction = async (...inputs) => {
        // Define the core transaction function without analytics
        const sendTransaction = async () => {
            if (!this.#account)
                throw new Error("not connected");
            const outputs = [];
            if (inputs.length === 1) {
                const { transaction, account, chain, options } = inputs[0];
                const { minContextSlot, preflightCommitment, skipPreflight, maxRetries, } = options ?? {};
                if (account !== this.#account)
                    throw new Error("invalid account");
                if (!isSolanaChain(chain))
                    throw new Error("invalid chain");
                const { signature } = await this.#civicWallet.signAndSendTransaction(VersionedTransaction.deserialize(transaction), {
                    preflightCommitment,
                    minContextSlot,
                    maxRetries,
                    skipPreflight,
                });
                outputs.push({ signature: bs58.decode(signature) });
            }
            else if (inputs.length > 1) {
                for (const input of inputs) {
                    outputs.push(...(await this.#signAndSendTransaction(input)));
                }
            }
            return outputs;
        };
        // Wrap with analytics and execute - pass inputs as analytics parameters
        return withAnalytics(sendTransaction, "signTransaction", "solana", inputs)();
    };
    #signTransaction = async (...inputs) => {
        // Define the core transaction signing function without analytics
        const signTransaction = async () => {
            if (!this.#account)
                throw new Error("not connected");
            const outputs = [];
            if (inputs.length === 1) {
                const { transaction, account, chain } = inputs[0];
                if (account !== this.#account)
                    throw new Error("invalid account");
                if (chain && !isSolanaChain(chain))
                    throw new Error("invalid chain");
                const signedTransaction = await this.#civicWallet.signTransaction(VersionedTransaction.deserialize(transaction));
                const serializedTransaction = signedTransaction.serialize();
                outputs.push({ signedTransaction: serializedTransaction });
            }
            else if (inputs.length > 1) {
                let chain = undefined;
                for (const input of inputs) {
                    if (input.account !== this.#account)
                        throw new Error("invalid account");
                    if (input.chain) {
                        if (!isSolanaChain(input.chain))
                            throw new Error("invalid chain");
                        if (chain) {
                            if (input.chain !== chain)
                                throw new Error("conflicting chain");
                        }
                        else {
                            chain = input.chain;
                        }
                    }
                }
                const transactions = inputs.map(({ transaction }) => VersionedTransaction.deserialize(transaction));
                const signedTransactions = await this.#civicWallet.signAllTransactions(transactions);
                outputs.push(...signedTransactions.map((signedTransaction) => {
                    const serializedTransaction = signedTransaction.serialize();
                    return { signedTransaction: serializedTransaction };
                }));
            }
            return outputs;
        };
        // Wrap with analytics and execute - pass inputs as analytics parameters
        return withAnalytics(signTransaction, "signTransaction", "solana", inputs)();
    };
    #signMessage = async (...inputs) => {
        // Define the core message signing function without analytics
        const signMessage = async () => {
            if (!this.#account)
                throw new Error("not connected");
            const outputs = [];
            if (inputs.length === 1) {
                const { message, account } = inputs[0];
                if (account !== this.#account)
                    throw new Error("invalid account");
                const { signature } = await this.#civicWallet.signMessage(message);
                outputs.push({ signedMessage: message, signature });
            }
            else if (inputs.length > 1) {
                for (const input of inputs) {
                    outputs.push(...(await this.#signMessage(input)));
                }
            }
            return outputs;
        };
        // Wrap with analytics and execute - pass inputs as analytics parameters
        return withAnalytics(signMessage, "signMessage", "solana", inputs)();
    };
    #signIn = async (...inputs) => {
        const outputs = [];
        if (inputs.length > 1) {
            for (const input of inputs) {
                outputs.push(await this.#civicWallet.signIn(input));
            }
        }
        else {
            return [await this.#civicWallet.signIn(inputs[0])];
        }
        return outputs;
    };
}
//# sourceMappingURL=wallet.js.map