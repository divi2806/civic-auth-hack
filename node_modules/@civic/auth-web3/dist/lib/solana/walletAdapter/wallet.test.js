/* eslint-disable @typescript-eslint/no-unused-vars */
import { describe, it, expect, beforeEach, afterEach, vi, } from "vitest";
import bs58 from "bs58";
import { Keypair, PublicKey, Transaction, VersionedTransaction, } from "@solana/web3.js";
import { CivicWalletAdapter } from "./wallet.js";
import { SOLANA_CHAINS } from "./solana.js";
import { StandardConnect, StandardDisconnect, StandardEvents, } from "@wallet-standard/features";
import { SolanaSignAndSendTransaction, SolanaSignTransaction, SolanaSignMessage, SolanaSignIn, } from "@solana/wallet-standard-features";
import { VersionedTransaction as VT } from "@solana/web3.js";
import * as solanaModule from "./solana.js";
import { CivicWalletAccount } from "./account.js";
import * as analyticsModule from "../../analytics/index.js";
const dummyPublicKey = () => Keypair.generate().publicKey;
// Use spies to mock deserialize and isVersionedTransaction
beforeEach(() => {
    vi.spyOn(VT, "deserialize").mockImplementation((tx) => tx);
    vi.spyOn(solanaModule, "isVersionedTransaction").mockReturnValue(true);
});
afterEach(() => {
    vi.restoreAllMocks();
});
function createDummyCivicWallet() {
    const listeners = {};
    // pulled out this function for casting reasons
    const signAllTransactions = vi.fn(async (txs) => {
        return txs.map((tx) => ({
            serialize: () => new Uint8Array([7, 7, 7]),
        }));
    });
    return {
        publicKey: dummyPublicKey(),
        on: vi.fn((event, callback) => {
            listeners[event] = listeners[event] || [];
            listeners[event].push(callback);
        }),
        _trigger(event, ...args) {
            listeners[event]?.forEach((cb) => cb(...args));
        },
        off: vi.fn((event, callback) => {
            if (!listeners[event])
                return;
            listeners[event] = listeners[event]?.filter((cb) => cb !== callback);
        }),
        removeListener: vi.fn((event, callback) => {
            if (!listeners[event])
                return;
            listeners[event] = listeners[event]?.filter((cb) => cb !== callback);
        }),
        // Use a non-arrow function so that 'this' is bound to the dummy wallet
        connect: vi.fn(async function (opts) {
            this.publicKey = dummyPublicKey();
            return { publicKey: this.publicKey };
        }),
        disconnect: vi.fn(async () => { }),
        signAndSendTransaction: vi.fn(async (tx, options) => {
            return { signature: bs58.encode(new Uint8Array([9, 8, 7])) };
        }),
        signTransaction: vi.fn(async (tx) => {
            return {
                serialize: () => new Uint8Array([4, 5, 6]),
            };
        }),
        signAllTransactions,
        signMessage: vi.fn(async (message) => {
            return { signature: new Uint8Array([1, 2, 3]) };
        }),
        signIn: vi.fn(async (input) => {
            return { dummy: "signIn" };
        }),
    };
}
describe("CivicWalletAdapter", () => {
    let dummyCivicWallet;
    let adapter;
    let emitEventSpy;
    beforeEach(() => {
        dummyCivicWallet = createDummyCivicWallet();
        adapter = new CivicWalletAdapter(dummyCivicWallet);
        // Mock the analyticsEmitter.emitEvent method
        emitEventSpy = vi
            .spyOn(analyticsModule.analyticsEmitter, "emitEvent")
            .mockResolvedValue();
    });
    afterEach(() => {
        if (emitEventSpy) {
            emitEventSpy.mockRestore();
        }
    });
    it("should expose correct getters", () => {
        expect(adapter.version).toBe("1.0.0");
        expect(adapter.name).toBe("Civic Wallet");
        expect(adapter.icon).toBeDefined();
        expect(adapter.chains).toEqual(SOLANA_CHAINS);
        expect(adapter.accounts.length).toBe(1);
    });
    it("should connect (via features) and update account", async () => {
        dummyCivicWallet.publicKey = null;
        dummyCivicWallet._trigger("disconnect");
        expect(adapter.accounts.length).toBe(0);
        const result = await adapter.features[StandardConnect].connect({
            silent: true,
        });
        expect(dummyCivicWallet.connect).toHaveBeenCalled();
        expect(adapter.accounts.length).toBe(1);
        expect(result.accounts.length).toBe(1);
    });
    it("should disconnect and update account", async () => {
        expect(adapter.accounts.length).toBe(1);
        await adapter.features[StandardDisconnect].disconnect();
        dummyCivicWallet.publicKey = null;
        dummyCivicWallet._trigger("disconnect");
        expect(adapter.accounts.length).toBe(0);
    });
    it("should disconnect when reconnected with no publicKey", () => {
        // Simulate a scenario where the wallet has no publicKey
        dummyCivicWallet.publicKey = null;
        dummyCivicWallet._trigger("accountChanged");
        expect(adapter.accounts.length).toBe(0);
    });
    it("should reconnect when reconnected with a new publicKey", async () => {
        // First, simulate a disconnect.
        dummyCivicWallet.publicKey = null;
        dummyCivicWallet._trigger("disconnect");
        expect(adapter.accounts.length).toBe(0);
        // Now, connect again to get a new publicKey.
        await adapter.features[StandardConnect].connect({ silent: true });
        // Trigger a reconnected event; the adapter should detect the new publicKey.
        dummyCivicWallet._trigger("accountChanged");
        expect(adapter.accounts.length).toBe(1);
    });
    it('should emit "change" event on account change', async () => {
        const changeListener = vi.fn();
        adapter.features[StandardEvents].on("change", changeListener);
        // The adapter was already connected during construction.
        // Call connect again to trigger a change (since dummyPublicKey key).
        await adapter.features[StandardDisconnect].disconnect();
        dummyCivicWallet._trigger("disconnect");
        await adapter.features[StandardConnect].connect();
        expect(changeListener).toHaveBeenCalled();
    });
    it("should allow adding multiple listeners", async () => {
        const changeListener1 = vi.fn();
        const changeListener2 = vi.fn();
        adapter.features[StandardEvents].on("change", changeListener1);
        adapter.features[StandardEvents].on("change", changeListener2);
        // The adapter was already connected during construction.
        // Call connect again to trigger a change (since dummyPublicKey key).
        await adapter.features[StandardDisconnect].disconnect();
        dummyCivicWallet._trigger("disconnect");
        await adapter.features[StandardConnect].connect();
        expect(changeListener1).toHaveBeenCalled();
        expect(changeListener2).toHaveBeenCalled();
    });
    it("should allow the removal of listeners", async () => {
        const changeListener = vi.fn();
        const removeListenerCallback = adapter.features[StandardEvents].on("change", changeListener);
        removeListenerCallback();
        // trigger a change event
        await adapter.features[StandardDisconnect].disconnect();
        dummyCivicWallet._trigger("disconnect");
        await adapter.features[StandardConnect].connect();
        // the listener should not have been called
        expect(changeListener).not.toHaveBeenCalled();
    });
    it("should throw error for signAndSendTransaction when not connected", async () => {
        dummyCivicWallet.publicKey = null;
        dummyCivicWallet._trigger("disconnect");
        await expect(adapter.features[SolanaSignAndSendTransaction].signAndSendTransaction({
            transaction: new Uint8Array([]),
            account: {
                address: "any",
                publicKey: new Uint8Array([]),
                chains: [],
                features: [],
            },
            chain: SOLANA_CHAINS[0],
            options: {},
        })).rejects.toThrow("not connected");
    });
    it("should sign and send transaction (single input)", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
            options: { preflightCommitment: "finalized" },
        };
        const outputs = await adapter.features[SolanaSignAndSendTransaction].signAndSendTransaction(input);
        expect(outputs).toHaveLength(1);
        const expectedSig = bs58.decode(bs58.encode(new Uint8Array([9, 8, 7])));
        expect(outputs[0]?.signature).toEqual(expectedSig);
    });
    it("should sign and send transaction (no options)", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
        };
        const outputs = await adapter.features[SolanaSignAndSendTransaction].signAndSendTransaction(input);
        expect(outputs).toHaveLength(1);
        const expectedSig = bs58.decode(bs58.encode(new Uint8Array([9, 8, 7])));
        expect(outputs[0]?.signature).toEqual(expectedSig);
    });
    it("should throw an error on sign and send transaction if the chain is unrecognised", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: "unknown:unknown",
        };
        const shouldFail = adapter.features[SolanaSignAndSendTransaction].signAndSendTransaction(input);
        await expect(shouldFail).rejects.toThrow("invalid chain");
    });
    it("should sign and send multiple transactions", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input1 = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
            options: { preflightCommitment: "finalized" },
        };
        const input2 = { ...input1 };
        const outputs = await adapter.features[SolanaSignAndSendTransaction].signAndSendTransaction(input1, input2);
        expect(outputs).toHaveLength(2);
    });
    it("should sign a transaction (single input) and track analytics", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
        };
        const outputs = await adapter.features[SolanaSignTransaction].signTransaction(input);
        expect(outputs).toHaveLength(1);
        expect(outputs[0]?.signedTransaction).toEqual(new Uint8Array([4, 5, 6]));
        // Verify analytics event was emitted
        expect(emitEventSpy).toHaveBeenCalledWith(expect.objectContaining({
            eventType: "signTransaction",
            parameters: expect.arrayContaining([expect.anything()]),
        }));
    });
    it("should throw an error when signing a transaction if the wallet is not connected", async () => {
        dummyCivicWallet._trigger("disconnect");
        const input = {
            transaction: new Uint8Array([1, 2, 3]),
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
        };
        const shouldFail = adapter.features[SolanaSignTransaction].signTransaction(input);
        await expect(shouldFail).rejects.toThrow("not connected");
    });
    it("should throw an error when signing a transaction (multiple inputs) if the input chain is invalid", async () => {
        const input1 = {
            transaction: new Uint8Array([1, 2, 3]),
            account: adapter.accounts[0],
            chain: "unknown:unknown",
        };
        const input2 = { ...input1 };
        const shouldFail = adapter.features[SolanaSignTransaction].signTransaction(input1, input2);
        await expect(shouldFail).rejects.toThrow("invalid chain");
    });
    it("should throw an error when signing a transaction (multiple inputs) if the input chains differ", async () => {
        const input1 = {
            transaction: new Uint8Array([1, 2, 3]),
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
        };
        const input2 = { ...input1, chain: SOLANA_CHAINS[1] };
        const shouldFail = adapter.features[SolanaSignTransaction].signTransaction(input1, input2);
        await expect(shouldFail).rejects.toThrow("conflicting chain");
    });
    it("should throw an error when signing a transaction (multiple inputs) if the input account is not the connected one", async () => {
        const someOtherAccount = {
            address: "any",
            publicKey: new Uint8Array([]),
            chains: [],
            features: [],
        };
        const input1 = {
            transaction: new Uint8Array([1, 2, 3]),
            account: someOtherAccount,
            chain: SOLANA_CHAINS[0],
        };
        const input2 = { ...input1 };
        const shouldFail = adapter.features[SolanaSignTransaction].signTransaction(input1, input2);
        await expect(shouldFail).rejects.toThrow("invalid account");
    });
    it("should sign multiple transactions", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input1 = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: SOLANA_CHAINS[0],
        };
        const input2 = { ...input1 };
        const outputs = await adapter.features[SolanaSignTransaction].signTransaction(input1, input2);
        expect(outputs).toHaveLength(2);
        outputs.forEach((output) => {
            expect(output.signedTransaction).toEqual(new Uint8Array([7, 7, 7]));
        });
    });
    it("should sign a message and track analytics", async () => {
        const message = new Uint8Array([10, 20, 30]);
        const input = {
            message,
            account: adapter.accounts[0],
        };
        const outputs = await adapter.features[SolanaSignMessage].signMessage(input);
        expect(outputs).toHaveLength(1);
        expect(outputs[0]?.signedMessage).toEqual(message);
        expect(outputs[0]?.signature).toEqual(new Uint8Array([1, 2, 3]));
        // Verify analytics event was emitted
        expect(emitEventSpy).toHaveBeenCalledWith(expect.objectContaining({
            eventType: "signMessage",
            parameters: expect.arrayContaining([expect.anything()]),
        }));
    });
    it("should throw an error on signMessage if not connected and track error analytics", async () => {
        dummyCivicWallet._trigger("disconnect");
        const input = {
            message: new Uint8Array([10, 20, 30]),
            account: adapter.accounts[0],
        };
        const shouldFail = adapter.features[SolanaSignMessage].signMessage(input);
        await expect(shouldFail).rejects.toThrow("not connected");
        // Verify error analytics event was emitted
        expect(emitEventSpy).toHaveBeenCalledWith(expect.objectContaining({
            eventType: "signMessageError",
            error: expect.stringContaining("not connected"),
            parameters: expect.arrayContaining([expect.anything()]),
        }));
    });
    it("should sign multiple messages", async () => {
        const message = new Uint8Array([10, 20, 30]);
        const input1 = { message, account: adapter.accounts[0] };
        const input2 = { message, account: adapter.accounts[0] };
        const outputs = await adapter.features[SolanaSignMessage].signMessage(input1, input2);
        expect(outputs).toHaveLength(2);
    });
    it("should sign in (single input)", async () => {
        const input = { statement: "input" };
        const outputs = await adapter.features[SolanaSignIn].signIn(input);
        expect(outputs).toHaveLength(1);
        expect(outputs[0]).toEqual({ dummy: "signIn" });
    });
    it("should sign in multiple times", async () => {
        const input1 = { statement: "input1" };
        const input2 = { statement: "input2" };
        const outputs = await adapter.features[SolanaSignIn].signIn(input1, input2);
        expect(outputs).toHaveLength(2);
    });
    it("should throw error for signAndSendTransaction with mismatched account", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const fakeAccount = {
            address: "fake",
            publicKey: new Uint8Array([0]),
            chains: [],
            features: [],
        };
        const input = {
            transaction: dummyTx,
            account: fakeAccount,
            chain: SOLANA_CHAINS[0],
            options: { preflightCommitment: "finalized" },
        };
        await expect(adapter.features[SolanaSignAndSendTransaction].signAndSendTransaction(input)).rejects.toThrow("invalid account");
    });
    it("should throw error for signTransaction with mismatched account", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const fakeAccount = {
            address: "fake",
            publicKey: new Uint8Array([0]),
            chains: [],
            features: [],
        };
        const input = {
            transaction: dummyTx,
            account: fakeAccount,
            chain: SOLANA_CHAINS[0],
        };
        await expect(adapter.features[SolanaSignTransaction].signTransaction(input)).rejects.toThrow("invalid account");
    });
    it("should throw error for signTransaction with invalid chain", async () => {
        const dummyTx = new Uint8Array([1, 2, 3]);
        const input = {
            transaction: dummyTx,
            account: adapter.accounts[0],
            chain: "invalid:chain",
        };
        await expect(adapter.features[SolanaSignTransaction].signTransaction(input)).rejects.toThrow("invalid chain");
    });
    it("should throw error for signMessage with mismatched account", async () => {
        const message = new Uint8Array([10, 20, 30]);
        const fakeAccount = {
            address: "fake",
            publicKey: new Uint8Array([0]),
            chains: [],
            features: [],
        };
        const input = { message, account: fakeAccount };
        await expect(adapter.features[SolanaSignMessage].signMessage(input)).rejects.toThrow("invalid account");
    });
});
//# sourceMappingURL=wallet.test.js.map