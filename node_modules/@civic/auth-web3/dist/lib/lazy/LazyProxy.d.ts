export type LazyProxy<T extends object> = T & ProxyHandler<T> & {
    setImplementation(impl: T): void;
    clearImplementation(): void;
    getImplementation(): T | null;
    ready(): boolean;
};
export type EventMap = Record<string, (...args: any[]) => void>;
/**
 * A utility type to represent an EventRegistrar with typed event handling.
 */
export type EventRegistrar<TEventMap extends EventMap> = {
    on<TEvent extends keyof TEventMap>(event: TEvent, listener: TEventMap[TEvent]): void;
    removeListener<TEvent extends keyof TEventMap>(event: TEvent, listener: TEventMap[TEvent]): void;
};
/**
 * Creates a lazy proxy that defers method/property access to the underlying implementation
 * until it's set. The proxy also handles event registration, storing listeners before the
 * implementation is set, and forwarding them once it becomes available.
 *
 * @param knownMethods - An optional list of methods to "recognize" for runtime duck typing.
 *   If specified, the proxy will return dummy functions for these methods until the implementation
 *   is set, allowing `if (proxy.someMethod)` checks to work. Defaults to an empty array.
 *
 * @returns A proxy object that combines the laziness and event handling of the underlying type.
 */
export declare const createLazyProxy: <TUnderlying extends EventRegistrar<TEventMap>, TEventMap extends EventMap>(knownMethods?: (keyof TUnderlying)[]) => LazyProxy<TUnderlying>;
//# sourceMappingURL=LazyProxy.d.ts.map