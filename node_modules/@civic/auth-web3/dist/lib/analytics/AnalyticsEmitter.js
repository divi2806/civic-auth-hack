import { VERSION } from "../../shared/version.js";
/**
 * Frontend analytics event emitter for the civic auth wallet SDK
 */
import { env } from "../utils.js";
// Helper functions for error handling
const toErrorType = (eventType) => `${eventType}Error`;
const errorToMessage = (error) => {
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
};
const randomFlowId = () => Math.random().toString(36).substring(7);
// Default endpoints for analytics
// Use the same base URL that's used for wallet access
const DEFAULT_METAKEEP_PROXY_ENDPOINT = ((baseUrl) => {
    return baseUrl + (baseUrl.endsWith("/") ? "" : "/") + "analytics/proxy";
})(env.NEXT_PUBLIC_WALLET_API_BASE_URL || "https://api.civic.com/metakeep");
function bigIntReplacer(_key, value) {
    if (typeof value === "bigint")
        return value.toString() + "n";
    return value;
}
// POST to the analytics SNS via metakeep-proxy
const emitToAnalyticsEndpoint = async (event, config) => {
    // Use proxy endpoint to bypass firewall restrictions (Civic origin requirement)
    const endpoint = config.endpoint ?? DEFAULT_METAKEEP_PROXY_ENDPOINT;
    const flowId = config.flowId ?? randomFlowId();
    const payload = {
        source: `civic-auth-metakeep${process.env.NODE_ENV !== "production" ? "-dev" : ""}`,
        target: event.target ?? "N/A",
        sdkVersion: VERSION,
        ...event,
    };
    // Build headers object
    const headers = {
        "content-type": "application/json",
        "x-civic-flow-id": flowId,
        "x-set-origin": "auth.civic.com",
    };
    // Add JWT token if available
    if (config.jwt) {
        headers["Authorization"] = `Bearer ${config.jwt}`;
    }
    // Add a custom header that the proxy service can use to set Origin:auth.civic.com
    // when forwarding to the actual analytics endpoint
    return fetch(endpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(payload, bigIntReplacer),
    });
};
// Given a function, return the same function wrapped with an analytics event that is emitted after the function is called successfully
const wrapFnWithAnalytics = (fn, emitter, eventType) => async (...args) => {
    let event = undefined;
    try {
        const result = await fn(...args);
        event = {
            eventType,
            parameters: args,
        };
        return result;
    }
    catch (error) {
        console.error("Failed to emit event to analytics endpoint", error);
        event = {
            eventType: toErrorType(eventType),
            error: errorToMessage(error),
            parameters: args,
        };
        throw error;
    }
    finally {
        await emitter.emitEvent(event);
    }
};
export class AnalyticsEmitter {
    config;
    jwtProvider;
    constructor(config) {
        this.config = config;
    }
    // Set a function that will provide the JWT token at runtime
    setJwtProvider(provider) {
        this.jwtProvider = provider;
    }
    async emitEvent(event) {
        try {
            // Get the JWT if a provider is set
            let jwt;
            if (this.jwtProvider) {
                jwt = this.jwtProvider();
                // Skip sending analytics if JWT isn't available yet
                if (!jwt) {
                    // Using console.log for test compatibility
                    console.log("Analytics: No JWT available, skipping analytics event");
                    return;
                }
            }
            // Get the latest config with the current JWT if available
            const currentConfig = {
                ...this.config,
                ...(jwt && { jwt }),
            };
            await emitToAnalyticsEndpoint(event, currentConfig);
        }
        catch (error) {
            console.error("Failed to emit event to analytics endpoint", error);
        }
    }
    wrapFn(fn, eventType) {
        return wrapFnWithAnalytics(fn, this, eventType);
    }
}
//# sourceMappingURL=AnalyticsEmitter.js.map