import { expect, vi, describe, it, beforeEach, afterEach } from "vitest";
import { AnalyticsEmitter } from "./AnalyticsEmitter.js";
import { VERSION } from "../../shared/version.js";
describe("AnalyticsEmitter", () => {
    let analyticsEmitter;
    let globalFetch;
    beforeEach(() => {
        // Store the original fetch
        globalFetch = global.fetch;
        // Mock fetch for testing
        global.fetch = vi.fn().mockResolvedValue({
            ok: true,
            status: 200,
        });
        // Create a new analytics emitter for each test
        analyticsEmitter = new AnalyticsEmitter({
            endpoint: "https://test.example.com/analytics",
            flowId: "test-flow-id",
        });
    });
    afterEach(() => {
        // Restore the original fetch
        global.fetch = globalFetch;
        vi.resetAllMocks();
    });
    describe("emitEvent", () => {
        it("should call fetch with the correct parameters", async () => {
            const event = {
                eventType: "signMessage",
                parameters: ["test message"],
            };
            await analyticsEmitter.emitEvent(event);
            expect(global.fetch).toHaveBeenCalledTimes(1);
            expect(global.fetch).toHaveBeenCalledWith("https://test.example.com/analytics", expect.objectContaining({
                method: "POST",
                headers: expect.objectContaining({
                    "content-type": "application/json",
                    "x-civic-flow-id": "test-flow-id",
                    "x-set-origin": "auth.civic.com",
                }),
            }));
            // Check the body
            const mockCalls = global.fetch.mock
                .calls;
            expect(mockCalls.length).toBeGreaterThan(0);
            const callArgs = mockCalls[0] ? mockCalls[0][1] : undefined;
            expect(callArgs).toBeDefined();
            const parsedBody = callArgs ? JSON.parse(callArgs.body) : {};
            expect(parsedBody).toEqual(expect.objectContaining({
                source: expect.stringMatching(/^civic-auth-metakeep(-dev)?$/),
                target: "N/A", // Default value
                eventType: "signMessage",
                parameters: ["test message"],
                sdkVersion: VERSION,
            }));
        });
        it("should handle errors gracefully", async () => {
            // Mock console.error
            const consoleErrorMock = vi
                .spyOn(console, "error")
                .mockImplementation(() => { });
            // Make fetch throw an error
            global.fetch = vi.fn().mockRejectedValue(new Error("Network error"));
            const event = {
                eventType: "signMessage",
                parameters: ["test message"],
            };
            // This should not throw
            await analyticsEmitter.emitEvent(event);
            expect(consoleErrorMock).toHaveBeenCalledWith("Failed to emit event to analytics endpoint", expect.any(Error));
            consoleErrorMock.mockRestore();
        });
        it("should use default values when not provided", async () => {
            // Create a new emitter without config
            const defaultEmitter = new AnalyticsEmitter({});
            const event = {
                eventType: "signMessage",
                parameters: ["test message"],
            };
            await defaultEmitter.emitEvent(event);
            expect(global.fetch).toHaveBeenCalledTimes(1);
            // Check the endpoint
            const mockCalls = global.fetch.mock
                .calls;
            expect(mockCalls.length).toBeGreaterThan(0);
            const callUrl = mockCalls[0] ? mockCalls[0][0] : undefined;
            expect(callUrl).toContain("/analytics/proxy");
            // Check the flowId was generated
            const callArgs = mockCalls[0] ? mockCalls[0][1] : undefined;
            expect(callArgs).toBeDefined();
            const headers = callArgs?.headers;
            expect(headers["x-civic-flow-id"]).toBeTruthy();
        });
        it("should handle bigint values in parameters", async () => {
            const event = {
                eventType: "signTransaction",
                parameters: [{ value: BigInt(123456789) }],
            };
            await analyticsEmitter.emitEvent(event);
            // Check the body
            const mockCalls = global.fetch.mock
                .calls;
            expect(mockCalls.length).toBeGreaterThan(0);
            const callArgs = mockCalls[0] ? mockCalls[0][1] : undefined;
            expect(callArgs).toBeDefined();
            const parsedBody = callArgs ? JSON.parse(callArgs.body) : {};
            expect(parsedBody.parameters[0].value).toBe("123456789n");
        });
        it("should include JWT token in headers when provided in config", async () => {
            // Create a new emitter with JWT token
            const jwtEmitter = new AnalyticsEmitter({
                endpoint: "https://test.example.com/analytics",
                flowId: "test-flow-id",
                jwt: "test-jwt-token",
            });
            const event = {
                eventType: "signMessage",
                parameters: ["test message"],
            };
            await jwtEmitter.emitEvent(event);
            expect(global.fetch).toHaveBeenCalledTimes(1);
            expect(global.fetch).toHaveBeenCalledWith("https://test.example.com/analytics", expect.objectContaining({
                method: "POST",
                headers: expect.objectContaining({
                    "content-type": "application/json",
                    "x-civic-flow-id": "test-flow-id",
                    "x-set-origin": "auth.civic.com",
                    Authorization: "Bearer test-jwt-token",
                }),
            }));
        });
        it("should include JWT token from the jwtProvider when set", async () => {
            // Create a new emitter without JWT token
            const jwtEmitter = new AnalyticsEmitter({
                endpoint: "https://test.example.com/analytics",
                flowId: "test-flow-id",
            });
            // Set a JWT provider function
            jwtEmitter.setJwtProvider(() => "provider-jwt-token");
            const event = {
                eventType: "signMessage",
                parameters: ["test message"],
            };
            await jwtEmitter.emitEvent(event);
            expect(global.fetch).toHaveBeenCalledTimes(1);
            expect(global.fetch).toHaveBeenCalledWith("https://test.example.com/analytics", expect.objectContaining({
                method: "POST",
                headers: expect.objectContaining({
                    "content-type": "application/json",
                    "x-civic-flow-id": "test-flow-id",
                    "x-set-origin": "auth.civic.com",
                    Authorization: "Bearer provider-jwt-token",
                }),
            }));
        });
        it("should skip sending event when JWT provider returns undefined", async () => {
            // Create a new emitter without JWT token
            const jwtEmitter = new AnalyticsEmitter({
                endpoint: "https://test.example.com/analytics",
                flowId: "test-flow-id",
            });
            // Mock console.log to check for the message
            const consoleLogMock = vi
                .spyOn(console, "log")
                .mockImplementation(() => { });
            // Set a JWT provider function that returns undefined
            jwtEmitter.setJwtProvider(() => undefined);
            const event = {
                eventType: "signMessage",
                parameters: ["test message"],
            };
            await jwtEmitter.emitEvent(event);
            // Verify that fetch was NOT called
            expect(global.fetch).not.toHaveBeenCalled();
            // Verify that console.log was called with the expected message
            expect(consoleLogMock).toHaveBeenCalledWith("Analytics: No JWT available, skipping analytics event");
            consoleLogMock.mockRestore();
        });
    });
    describe("wrapFn", () => {
        it("should call the wrapped function and emit success event", async () => {
            const mockFn = vi.fn().mockResolvedValue("success result");
            const wrappedFn = analyticsEmitter.wrapFn(mockFn, "signMessage");
            const result = await wrappedFn("test arg");
            // Function should be called with the original arguments
            expect(mockFn).toHaveBeenCalledWith("test arg");
            // Result should be passed through
            expect(result).toBe("success result");
            // Event should be emitted
            expect(global.fetch).toHaveBeenCalledTimes(1);
            // Check the body for success event
            const mockCalls = global.fetch.mock
                .calls;
            expect(mockCalls.length).toBeGreaterThan(0);
            const callArgs = mockCalls[0] ? mockCalls[0][1] : undefined;
            expect(callArgs).toBeDefined();
            const parsedBody = callArgs ? JSON.parse(callArgs.body) : {};
            expect(parsedBody).toEqual(expect.objectContaining({
                eventType: "signMessage",
                parameters: ["test arg"],
                sdkVersion: VERSION,
            }));
            expect(parsedBody.error).toBeUndefined();
        });
        it("should emit error event when the wrapped function throws", async () => {
            const testError = new Error("test error");
            const mockFn = vi.fn().mockRejectedValue(testError);
            // Mock console.error
            const consoleErrorMock = vi
                .spyOn(console, "error")
                .mockImplementation(() => { });
            const wrappedFn = analyticsEmitter.wrapFn(mockFn, "signTransaction");
            // The wrapped function should throw the original error
            await expect(wrappedFn("test arg")).rejects.toThrow(testError);
            // Event should be emitted
            expect(global.fetch).toHaveBeenCalledTimes(1);
            // Check the body for error event
            const mockCalls = global.fetch.mock
                .calls;
            expect(mockCalls.length).toBeGreaterThan(0);
            const callArgs = mockCalls[0] ? mockCalls[0][1] : undefined;
            expect(callArgs).toBeDefined();
            const parsedBody = callArgs ? JSON.parse(callArgs.body) : {};
            expect(parsedBody).toEqual(expect.objectContaining({
                eventType: "signTransactionError",
                parameters: ["test arg"],
                error: "test error",
            }));
            consoleErrorMock.mockRestore();
        });
        it("should handle non-Error objects when formatting error messages", async () => {
            // Use a plain object or string as the error value
            const nonErrorObject = { reason: "operation failed", code: 123 };
            const mockFn = vi.fn().mockRejectedValue(nonErrorObject);
            // Mock console.error
            const consoleErrorMock = vi
                .spyOn(console, "error")
                .mockImplementation(() => { });
            const wrappedFn = analyticsEmitter.wrapFn(mockFn, "signMessage");
            // The wrapped function should throw the original error
            await expect(wrappedFn("test arg")).rejects.toEqual(nonErrorObject);
            // Event should be emitted
            expect(global.fetch).toHaveBeenCalledTimes(1);
            // Check the body for error event
            const mockCalls = global.fetch.mock
                .calls;
            expect(mockCalls.length).toBeGreaterThan(0);
            const callArgs = mockCalls[0] ? mockCalls[0][1] : undefined;
            expect(callArgs).toBeDefined();
            const parsedBody = callArgs ? JSON.parse(callArgs.body) : {};
            // The error should be JSON stringified
            expect(parsedBody).toEqual(expect.objectContaining({
                eventType: "signMessageError",
                parameters: ["test arg"],
                error: JSON.stringify(nonErrorObject),
            }));
            consoleErrorMock.mockRestore();
        });
    });
});
//# sourceMappingURL=AnalyticsEmitter.test.js.map