{"version":3,"file":"middleware.js","sourceRoot":"","sources":["../../../src/lib/analytics/middleware.ts"],"names":[],"mappings":"AAAA;;GAEG;AAEH,OAAO,EAAE,gBAAgB,EAAE,MAAM,YAAY,CAAC;AAG9C;;;;;;;;;GASG;AACH,MAAM,UAAU,aAAa,CAC3B,EAAiC,EACjC,SAAiC,EACjC,MAAe,EACf,eAAoC;IAEpC,OAAO,KAAK,EAAE,GAAG,IAAU,EAAc,EAAE;QACzC,uEAAuE;QACvE,MAAM,UAAU,GAAG,eAAe,IAAI,IAAI,CAAC;QAE3C,IAAI,CAAC;YACH,gCAAgC;YAChC,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YAEjC,qBAAqB;YACrB,MAAM,gBAAgB,CAAC,SAAS,CAAC;gBAC/B,SAAS;gBACT,UAAU;gBACV,GAAG,CAAC,MAAM,IAAI,EAAE,MAAM,EAAE,CAAC;aAC1B,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC;QAChB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,mBAAmB;YACnB,MAAM,gBAAgB,CAAC,SAAS,CAAC;gBAC/B,SAAS,EAAE,GAAG,SAAS,OAAO;gBAC9B,KAAK,EAAE,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;gBAC7D,UAAU;gBACV,GAAG,CAAC,MAAM,IAAI,EAAE,MAAM,EAAE,CAAC;aAC1B,CAAC,CAAC;YAEH,8BAA8B;YAC9B,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * Analytics middleware to provide a unified approach to analytics across different chains\n */\n\nimport { analyticsEmitter } from \"./index.js\";\nimport type { CivicAuthWeb3EventType } from \"./types.js\";\n\n/**\n * Wraps a function with analytics tracking, handling both success and error cases\n * This can be used by any chain implementation\n *\n * @param fn The function to wrap\n * @param eventType The type of event to track\n * @param target Optional target identifier (e.g., \"ethereum\", \"solana\")\n * @param analyticsParams Optional parameters to include in the analytics event\n * @returns The wrapped function\n */\nexport function withAnalytics<Args extends unknown[], R>(\n  fn: (...args: Args) => Promise<R>,\n  eventType: CivicAuthWeb3EventType,\n  target?: string,\n  analyticsParams?: readonly unknown[],\n): (...args: Args) => Promise<R> {\n  return async (...args: Args): Promise<R> => {\n    // Use custom analytics params if provided, otherwise use function args\n    const parameters = analyticsParams || args;\n\n    try {\n      // Execute the original function\n      const result = await fn(...args);\n\n      // Emit success event\n      await analyticsEmitter.emitEvent({\n        eventType,\n        parameters,\n        ...(target && { target }),\n      });\n\n      return result;\n    } catch (error) {\n      // Emit error event\n      await analyticsEmitter.emitEvent({\n        eventType: `${eventType}Error`,\n        error: error instanceof Error ? error.message : String(error),\n        parameters,\n        ...(target && { target }),\n      });\n\n      // Re-throw the original error\n      throw error;\n    }\n  };\n}\n"]}