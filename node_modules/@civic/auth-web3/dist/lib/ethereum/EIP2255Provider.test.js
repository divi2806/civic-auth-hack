import { describe, it, expect, vi } from "vitest";
import { wrapWithEIP2255, EIP2255ProviderImpl } from "./EIP2255Provider.js";
describe("EIP2255ProviderImpl", () => {
    let provider;
    beforeEach(() => {
        provider = new EIP2255ProviderImpl();
    });
    describe("unrecognised requests", () => {
        it("should throw an error", async () => {
            const shouldFail = provider.request({
                // hack typescript to be able to test this - note - we can't rely on the integrator being typesafe here
                method: "unrecognised",
                params: [],
            });
            await expect(shouldFail).rejects.toThrowError("unrecognised");
        });
    });
    describe("wallet_getPermissions", () => {
        it("should return empty array when no permissions are set", async () => {
            const result = await provider.request({
                method: "wallet_getPermissions",
                params: [],
            });
            expect(result).toEqual([]);
        });
    });
    describe("wallet_requestPermissions", () => {
        it("should add new permission", async () => {
            const requested = { eth_sign: {} };
            const result = await provider.request({
                method: "wallet_requestPermissions",
                params: [requested],
            });
            expect(result).toHaveLength(1);
            expect(result?.[0]?.parentCapability).toBe("eth_sign");
        });
        it("should update existing permission with new caveats", async () => {
            // First request
            const initialRequest = { eth_sign: {} };
            await provider.request({
                method: "wallet_requestPermissions",
                params: [initialRequest],
            });
            // Second request with additional caveat
            const updatedRequest = { eth_sign: { test: true } };
            const result = await provider.request({
                method: "wallet_requestPermissions",
                params: [updatedRequest],
            });
            expect(result?.[0]?.caveats).toHaveLength(1);
            expect(result?.[0]?.caveats[0]).toEqual({ type: "test", value: true });
        });
    });
    describe("wallet_revokePermissions", () => {
        it("should remove a permission", async () => {
            const requested = { eth_sign: {} };
            const result = await provider.request({
                method: "wallet_grantPermissions",
                params: [requested],
            });
            expect(result).toHaveLength(1);
            expect(result?.[0]?.parentCapability).toBe("eth_sign");
            await provider.request({
                method: "wallet_revokePermissions",
                params: [requested],
            });
            const getResult = await provider.request({
                method: "wallet_getPermissions",
                params: [],
            });
            expect(getResult).toEqual([]);
        });
    });
});
describe("wrapWithEIP2255", () => {
    let underlyingProvider;
    // the wrapped provider implements both the dummy methods and EIP-2255
    let wrappedProvider;
    beforeEach(() => {
        underlyingProvider = {
            request: vi.fn(),
        };
        wrappedProvider = wrapWithEIP2255(underlyingProvider);
    });
    describe("request method", () => {
        it("should handle EIP-2255 methods through wrapper", async () => {
            const result = await wrappedProvider.request({
                method: "wallet_getPermissions",
            });
            expect(result).toEqual([]);
        });
        it("should forward non-EIP-2255 methods to underlying provider", async () => {
            const mockMethod = vi.fn();
            vi.mocked(underlyingProvider.request).mockImplementation(mockMethod);
            const request = {
                method: "some_method",
                params: "dummy param",
            };
            await wrappedProvider.request(request);
            expect(mockMethod).toHaveBeenCalledWith(request);
        });
    });
    describe("setting properties", () => {
        it("is not allowed", () => {
            expect(() => {
                wrappedProvider.abc = true;
            }).toThrowError();
        });
    });
});
//# sourceMappingURL=EIP2255Provider.test.js.map