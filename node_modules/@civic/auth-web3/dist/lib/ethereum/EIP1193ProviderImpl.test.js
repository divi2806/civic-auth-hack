import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { EIP1193ProviderImpl } from "./EIP1193ProviderImpl.js";
import * as analyticsModule from "../analytics/index.js";
// Mock GenericEthereumProvider
class MockProvider {
    request = vi.fn();
    on = vi.fn();
    removeListener = vi.fn();
}
// Create a mock provider with event support
const createMockProvider = (supportsEvents = true) => {
    const mock = new MockProvider();
    if (!supportsEvents) {
        delete mock.on;
        delete mock.removeListener;
    }
    return mock;
};
describe("EIP1193ProviderImpl", () => {
    it("should wrap a GenericEthereumProvider and expose the EIP-1193 interface", () => {
        const mockProvider = createMockProvider();
        const provider = new EIP1193ProviderImpl(mockProvider);
        expect(typeof provider.request).toBe("function");
        expect(typeof provider.on).toBe("function");
        expect(typeof provider.removeListener).toBe("function");
    });
    describe("request method", () => {
        // Store the original implementation
        const originalEmitEvent = analyticsModule.analyticsEmitter.emitEvent;
        const mockEmitEvent = vi.fn().mockResolvedValue(undefined);
        beforeEach(() => {
            // Reset the mock for each test
            mockEmitEvent.mockClear();
            // Replace the real method with our mock
            analyticsModule.analyticsEmitter.emitEvent = mockEmitEvent;
        });
        afterEach(() => {
            // Restore the original implementation after each test
            analyticsModule.analyticsEmitter.emitEvent = originalEmitEvent;
        });
        it("should forward request calls to the underlying provider", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            vi.mocked(mockProvider.request).mockResolvedValueOnce("mockResponse");
            const result = await provider.request({ method: "eth_chainId" });
            expect(result).toBe("mockResponse");
            expect(mockProvider.request).toHaveBeenCalledWith({
                method: "eth_chainId",
            });
            // Non-tracked methods should not emit analytics
            expect(mockEmitEvent).not.toHaveBeenCalled();
        });
        it("should unwrap structured response for eth_signTypedData methods", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            vi.mocked(mockProvider.request).mockResolvedValueOnce({
                signature: "mockSignature",
                r: "r-value",
                s: "s-value",
                v: "v-value",
                status: "SUCCESS",
            });
            const request = {
                method: "eth_signTypedData_v4",
                params: [{ domain: {}, types: {}, message: {} }],
            };
            const result = await provider.request(request);
            expect(result).toBe("mockSignature");
            // Should emit analytics for signTypedData
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signTypedData",
                parameters: [request],
            }));
        });
        it("should throw an error if eth_signTypedData method fails", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            vi.mocked(mockProvider.request).mockResolvedValueOnce({
                status: "USER_REQUEST_DENIED",
            });
            const request = {
                method: "eth_signTypedData",
                params: [{ domain: {}, types: {}, message: {} }],
            };
            await expect(provider.request(request)).rejects.toThrow("Metakeep Error: USER_REQUEST_DENIED");
            // Should emit error analytics
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signTypedDataError",
                error: expect.any(String),
                parameters: [request],
            }));
        });
        it("should emit analytics for personal_sign requests", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            vi.mocked(mockProvider.request).mockResolvedValueOnce("0xsignature");
            const request = {
                method: "personal_sign",
                params: ["0xmessage"],
            };
            await provider.request(request);
            // Should emit analytics for signMessage
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signMessage",
                parameters: [request],
            }));
        });
        it("should emit analytics for eth_sendTransaction requests", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            vi.mocked(mockProvider.request).mockResolvedValueOnce("0xtxhash");
            const request = {
                method: "eth_sendTransaction",
                params: [{ to: "0xabc", value: "0x123" }],
            };
            await provider.request(request);
            // Should emit analytics for signTransaction
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signTransaction",
                parameters: [request],
            }));
        });
        it("should emit error analytics when a tracked method fails", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            const testError = new Error("User rejected");
            vi.mocked(mockProvider.request).mockRejectedValueOnce(testError);
            const request = {
                method: "eth_sendTransaction",
                params: [{ to: "0xabc", value: "0x123" }],
            };
            await expect(provider.request(request)).rejects.toThrow(testError);
            // Should emit error analytics
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signTransactionError",
                error: "User rejected",
                parameters: [request],
            }));
        });
        it("should emit error analytics for eth_sign method failures", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            const testError = new Error("Signing failed");
            vi.mocked(mockProvider.request).mockRejectedValueOnce(testError);
            const request = {
                method: "eth_sign",
                params: ["0xaddress", "0xmessage"],
            };
            await expect(provider.request(request)).rejects.toThrow(testError);
            // Should emit error analytics with correct event type
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signMessageError", // This specifically tests line 176
                error: "Signing failed",
                parameters: [request],
            }));
        });
        it("should emit error analytics for eth_signTypedData_v4 method failures", async () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            const testError = new Error("Typed data signing failed");
            vi.mocked(mockProvider.request).mockRejectedValueOnce(testError);
            const request = {
                method: "eth_signTypedData_v4",
                params: [{ domain: {}, types: {}, message: {} }],
            };
            await expect(provider.request(request)).rejects.toThrow(testError);
            // Should emit error analytics with correct event type
            expect(mockEmitEvent).toHaveBeenCalledWith(expect.objectContaining({
                eventType: "signTypedDataError", // This specifically tests line 170 & 177
                error: "Typed data signing failed",
                parameters: [request],
            }));
        });
    });
    describe("event handling", () => {
        it("should forward on() calls to the underlying provider if it supports events", () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            const listener = vi.fn();
            provider.on("accountsChanged", listener);
            expect(mockProvider.on).toHaveBeenCalledWith("accountsChanged", listener);
        });
        it("should capture events handlers locally if the provider lacks event support", () => {
            const mockProvider = createMockProvider(false);
            const provider = new EIP1193ProviderImpl(mockProvider);
            // this passes because the wrapper has its own event emitter
            provider.on("accountsChanged", vi.fn());
        });
        it("should forward removeListener() calls to the underlying provider if it supports events", () => {
            const mockProvider = createMockProvider();
            const provider = new EIP1193ProviderImpl(mockProvider);
            const listener = vi.fn();
            provider.removeListener("chainChanged", listener);
            expect(mockProvider.removeListener).toHaveBeenCalledWith("chainChanged", listener);
        });
        it("should remove listeners from the local EventEmitter if the provider lacks event support", () => {
            const mockProvider = createMockProvider(false);
            const provider = new EIP1193ProviderImpl(mockProvider);
            // this passes because the wrapper has its own event emitter
            provider.removeListener("accountsChanged", vi.fn());
        });
        it("should emit an event on disconnect", () => {
            const mockProvider = createMockProvider(false);
            const provider = new EIP1193ProviderImpl(mockProvider);
            const listener = vi.fn();
            provider.on("disconnect", listener);
            provider.disconnect();
            expect(listener).toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=EIP1193ProviderImpl.test.js.map