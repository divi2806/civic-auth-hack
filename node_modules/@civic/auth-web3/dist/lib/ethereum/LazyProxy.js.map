{"version":3,"file":"LazyProxy.js","sourceRoot":"","sources":["../../../src/lib/ethereum/LazyProxy.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from \"../logger.js\";\n\nexport type Proxy<T> = {\n  setImplementation(impl: T): void;\n  clearImplementation(): void;\n  ready(): boolean;\n};\n\n// In order to satisfy types with Viem's EventMap, we need to use any[] as the type for the listener\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype EventMap = Record<string, (...args: any[]) => void>;\n/**\n * A utility type to represent an EventRegistrar with typed event handling.\n */\nexport type EventRegistrar<TEventMap extends EventMap> = {\n  on<TEvent extends keyof TEventMap>(\n    event: TEvent,\n    listener: TEventMap[TEvent],\n  ): void;\n  removeListener<TEvent extends keyof TEventMap>(\n    event: TEvent,\n    listener: TEventMap[TEvent],\n  ): void;\n};\n\n/**\n * Creates a lazy proxy that defers method/property access to the underlying implementation\n * until it's set. The proxy also handles event registration, storing listeners before the\n * implementation is set, and forwarding them once it becomes available.\n *\n * @param knownMethods - An optional list of methods to \"recognize\" for runtime duck typing.\n *   If specified, the proxy will return dummy functions for these methods until the implementation\n *   is set, allowing `if (proxy.someMethod)` checks to work. Defaults to an empty array.\n *\n * @returns A proxy object that combines the laziness and event handling of the underlying type.\n */\nexport function createLazyProxy<\n  TUnderlying extends EventRegistrar<TEventMap>,\n  TEventMap extends EventMap,\n>(knownMethods: (keyof TUnderlying)[] = []): TUnderlying & Proxy<TUnderlying> {\n  let realImpl: TUnderlying | null = null;\n\n  // Lightweight target object: purely a placeholder for the proxy\n  const target: Record<string, unknown> = {};\n\n  // Listener store: Stores events and listeners before the implementation is ready\n  const listenerStore: Map<keyof TEventMap, TEventMap[keyof TEventMap][]> =\n    new Map();\n\n  return new Proxy(target as TUnderlying & Proxy<TUnderlying>, {\n    get(_target, prop, receiver) {\n      // Handle internal methods\n      if (prop === \"setImplementation\") {\n        return (impl: TUnderlying) => {\n          realImpl = impl;\n\n          // Forward all stored listeners to the real implementation\n          listenerStore.forEach((listeners, event) => {\n            listeners.forEach((listener) => {\n              logger.web3.provider.debug(\n                \"LazyProxy: Registering stored listener for\",\n                event,\n              );\n              impl.on(event, listener); // Delegate to real implementation\n            });\n          });\n          listenerStore.clear(); // Clear the listener store to avoid duplicates\n        };\n      } else if (prop === \"clearImplementation\") {\n        return () => {\n          realImpl = null;\n        };\n      }\n\n      if (prop === \"ready\") {\n        return () => !!realImpl; // Return whether the implementation is set\n      }\n\n      // Handle event methods: on and removeListener\n      if (prop === \"on\") {\n        return <Event extends keyof TEventMap>(\n          event: Event,\n          listener: TEventMap[Event],\n        ) => {\n          if (realImpl) {\n            logger.web3.provider.debug(\n              \"LazyProxy: Registering listener for\",\n              event,\n              \"on the real impl\",\n            );\n            realImpl.on(event, listener); // Forward to real implementation\n          } else {\n            logger.web3.provider.debug(\n              \"LazyProxy: Storing the listener for\",\n              event,\n              \" to be registered later on the real impl\",\n            );\n            // Store the listener if implementation is not ready\n            if (!listenerStore.has(event)) {\n              listenerStore.set(event, []);\n            }\n            listenerStore.get(event)!.push(listener);\n          }\n        };\n      }\n\n      if (prop === \"removeListener\") {\n        return <Event extends keyof TEventMap>(\n          event: Event,\n          listener: TEventMap[Event],\n        ) => {\n          if (realImpl) {\n            realImpl.removeListener(event, listener); // Forward to real implementation\n          } else {\n            // Remove the listener from the store\n            const listeners = listenerStore.get(event);\n            if (listeners) {\n              const index = listeners.indexOf(listener);\n              if (index !== -1) listeners.splice(index, 1);\n              if (listeners.length === 0) listenerStore.delete(event);\n            }\n          }\n        };\n      }\n\n      // Handle all other properties/methods\n      if (realImpl) {\n        return Reflect.get(realImpl, prop, receiver); // Forward to real implementation\n      }\n\n      if (knownMethods.includes(prop as keyof TUnderlying)) {\n        // Provide a dummy function for known methods to enable duck typing\n        return () => {\n          throw new Error(\n            `Lazy proxy: Method \"${String(prop)}\" cannot be called because the implementation is not set yet.`,\n          );\n        };\n      }\n\n      // Default behavior: Return undefined for unknown properties\n      return undefined;\n    },\n\n    set(_target, prop, value) {\n      if (prop === \"setImplementation\" || prop === \"ready\") {\n        Reflect.set(target, prop, value); // Allow defining internal methods\n        return true;\n      }\n\n      if (!realImpl) {\n        throw new Error(\"Lazy proxy: Implementation not set yet!\");\n      }\n      return Reflect.set(realImpl, prop, value); // Forward to real implementation\n    },\n  });\n}\n"]}