{"version":3,"file":"EIP1193ProviderImpl.js","sourceRoot":"","sources":["../../../src/lib/ethereum/EIP1193ProviderImpl.ts"],"names":[],"mappings":"AAAA,OAAO,EAIL,gBAAgB,GAIjB,MAAM,MAAM,CAAC;AAEd,OAAO,YAAY,MAAM,QAAQ,CAAC;AAClC,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AAGtC,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AAsBtD,MAAM,cAAc,GAAG,CACrB,UAAmC,EACoB,EAAE;IACzD,OAAO,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AAChE,CAAC,CAAC;AAgBF,MAAM,OAAO,mBAAmB;IAGtB,UAAU,CAA0B,CAAC,uBAAuB;IAC5D,iBAAiB,CAAqC;IAE9D,YAAY,QAAiC;QAC3C,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC;QAC3B,IAAI,CAAC,iBAAiB,GAAG,IAAI,YAAY,EAAwB,CAAC;IACpE,CAAC;IA8BD,4BAA4B;IAC5B,KAAK,CAAC,OAAO,CAAC,IAGb;QACC,kDAAkD;QAClD,IAAI,SAIS,CAAC;QACd,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,IAAI,IAAI,CAAC,MAAM,KAAK,eAAe,EAAE,CAAC;YAClE,SAAS,GAAG,aAAa,CAAC;YAC1B,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,kCAAkC,EAAE,IAAI,CAAC,CAAC;QACvE,CAAC;aAAM,IAAI,IAAI,CAAC,MAAM,KAAK,qBAAqB,EAAE,CAAC;YACjD,SAAS,GAAG,iBAAiB,CAAC;YAC9B,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,sCAAsC,EAAE,IAAI,CAAC,CAAC;QAC3E,CAAC;aAAM,IACL,IAAI,CAAC,MAAM,KAAK,mBAAmB;YACnC,IAAI,CAAC,MAAM,KAAK,sBAAsB,EACtC,CAAC;YACD,SAAS,GAAG,eAAe,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,oCAAoC,EAAE,IAAI,CAAC,CAAC;QACzE,CAAC;QAED,mEAAmE;QACnE,IACE,IAAI,CAAC,MAAM,KAAK,mBAAmB;YACnC,IAAI,CAAC,MAAM,KAAK,sBAAsB,EACtC,CAAC;YACD,6CAA6C;YAC7C,MAAM,mBAAmB,GAAG,KAAK,IAAI,EAAE;gBACrC,MAAM,kBAAkB,GACtB,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAA0B,CAAC;gBACjE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;gBAErE,IAAI,kBAAkB,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;oBAC5C,MAAM,IAAI,KAAK,CAAC,kBAAkB,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC;gBAClE,CAAC;gBAED,OAAO,kBAAkB,CAAC,SAAS,CAAC;YACtC,CAAC,CAAC;YAEF,2DAA2D;YAC3D,IAAI,SAAS,EAAE,CAAC;gBACd,OAAO,aAAa,CAAC,mBAAmB,EAAE,SAAS,EAAE,UAAU,EAAE;oBAC/D,IAAI;iBACI,CAAC,EAAE,CAAC;YAChB,CAAC;YAED,OAAO,mBAAmB,EAAE,CAAC;QAC/B,CAAC;QAED,uBAAuB;QACvB,MAAM,kBAAkB,GAAG,KAAK,IAAI,EAAE;YACpC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,8BAA8B,EAAE,IAAI,CAAC,CAAC;YACjE,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACnD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,qCAAqC,EAAE,MAAM,CAAC,CAAC;YAC1E,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC;QAEF,2DAA2D;QAC3D,IAAI,SAAS,EAAE,CAAC;YACd,OAAO,aAAa,CAAC,kBAAkB,EAAE,SAAS,EAAE,UAAU,EAAE;gBAC9D,IAAI;aACI,CAAC,EAAE,CAAC;QAChB,CAAC;QAED,OAAO,kBAAkB,EAAE,CAAC;IAC9B,CAAC;IAED,UAAU;QACR,IAAI,CAAC,iBAAiB,CAAC,IAAI,CACzB,YAAY,EACZ,IAAI,gBAAgB,CAAC,IAAI,KAAK,CAAC,sBAAsB,CAAC,EAAE;YACtD,YAAY,EAAE,sBAAsB;YACpC,IAAI,EAAE,IAAI;SACX,CAAC,CACH,CAAC;IACJ,CAAC;IAED,gCAAgC;IAChC,EAAE,CACA,KAAY,EACZ,QAAgC;QAEhC,4EAA4E;QAC5E,IAAI,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YACpC,0EAA0E;YACzE,IAAI,CAAC,UAAuC,CAAC,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACpE,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,iBAAiB,CAAC,EAAE,CACvB,KAAK;YACL,4FAA4F;YAC5F,QAA2D,CAC5D,CAAC;QACJ,CAAC;IACH,CAAC;IAED,cAAc,CACZ,KAAY,EACZ,QAAgC;QAEhC,4EAA4E;QAC5E,IAAI,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YACpC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QAClD,CAAC;aAAM,CAAC;YACN,4FAA4F;YAC5F,IAAI,CAAC,iBAAiB,CAAC,cAAc,CACnC,KAAK,EACL,QAAuE,CACxE,CAAC;QACJ,CAAC;IACH,CAAC;CACF","sourcesContent":["import {\n  type EIP1193EventMap,\n  type EIP1193Events,\n  type EIP1193Provider,\n  ProviderRpcError,\n  type SendTransactionParameters,\n  type SignableMessage,\n  type SignTypedDataParameters,\n} from \"viem\";\nimport type { GenericEthereumProvider } from \"../../types.js\";\nimport EventEmitter from \"events\";\nimport { logger } from \"../logger.js\";\nimport type { EIP2255Provider } from \"./EIP2255Provider.js\";\nimport type { EventRegistrar } from \"../lazy/LazyProxy.js\";\nimport { withAnalytics } from \"../analytics/index.js\";\n\ntype SignTypedDataResponse =\n  | {\n      signature: string;\n      r: string;\n      s: string;\n      v: string;\n      status: \"SUCCESS\";\n    }\n  | {\n      status:\n        | \"USER_REQUEST_DENIED\"\n        | \"SOMETHING_WENT_WRONG\"\n        | \"INVALID_REQUEST\";\n    };\n\nexport type TypedEthereumProvider = EIP1193Provider &\n  DisconnectableProvider &\n  EIP2255Provider &\n  EventRegistrar<EIP1193EventMap>;\n\nconst isEventHandler = (\n  underlying: GenericEthereumProvider,\n): underlying is EIP1193Events & GenericEthereumProvider => {\n  return Object.prototype.hasOwnProperty.call(underlying, \"on\");\n};\n\n// An EIP1193 provider that responds to remote disconnect requests\n// (e.g. when disconnect is triggered by an external request rather than internally in the wallet)\nexport interface DisconnectableProvider {\n  disconnect(): void;\n}\n\ntype EventEmitterEventMap = {\n  [K in keyof EIP1193EventMap]: EIP1193EventMap[K] extends (\n    ...args: infer P\n  ) => void\n    ? P\n    : never;\n};\n\nexport class EIP1193ProviderImpl\n  implements EIP1193Provider, DisconnectableProvider\n{\n  private underlying: GenericEthereumProvider; // a request() function\n  private localEventEmitter: EventEmitter<EventEmitterEventMap>;\n\n  constructor(provider: GenericEthereumProvider) {\n    this.underlying = provider;\n    this.localEventEmitter = new EventEmitter<EventEmitterEventMap>();\n  }\n\n  // If the underlying provider doesn't handle events,\n  // we add an event emitter to handle them.\n\n  /** Overloads for typed methods */\n  async request(args: {\n    method: \"eth_accounts\";\n    params?: unknown[];\n  }): Promise<string[]>;\n  async request(args: {\n    method: \"eth_chainId\";\n    params?: unknown[];\n  }): Promise<string>;\n  async request(args: {\n    method: \"eth_sendTransaction\";\n    params: [SendTransactionParameters];\n  }): Promise<string>;\n  async request(args: {\n    method: \"eth_sign\" | \"personal_sign\";\n    params: [SignableMessage];\n  }): Promise<string>;\n  async request(args: {\n    method: \"eth_signTypedData\" | \"eth_signTypedData_v4\";\n    params: [SignTypedDataParameters];\n  }): Promise<string>;\n\n  /** Fallback for any other method */\n  async request(args: { method: string; params?: unknown[] }): Promise<unknown>;\n\n  /** Single implementation */\n  async request(args: {\n    method: string;\n    params?: unknown[];\n  }): Promise<unknown> {\n    // Determine the event type for analytics tracking\n    let eventType:\n      | \"signMessage\"\n      | \"signTransaction\"\n      | \"signTypedData\"\n      | undefined;\n    if (args.method === \"eth_sign\" || args.method === \"personal_sign\") {\n      eventType = \"signMessage\";\n      logger.web3.provider.debug(\"EIP1193ProviderImpl: signMessage\", args);\n    } else if (args.method === \"eth_sendTransaction\") {\n      eventType = \"signTransaction\";\n      logger.web3.provider.debug(\"EIP1193ProviderImpl: sendTransaction\", args);\n    } else if (\n      args.method === \"eth_signTypedData\" ||\n      args.method === \"eth_signTypedData_v4\"\n    ) {\n      eventType = \"signTypedData\";\n      logger.web3.provider.debug(\"EIP1193ProviderImpl: signTypedData\", args);\n    }\n\n    // Special handling for signTypedData methods needs to be preserved\n    if (\n      args.method === \"eth_signTypedData\" ||\n      args.method === \"eth_signTypedData_v4\"\n    ) {\n      // Create a wrapped handler for signTypedData\n      const handleSignTypedData = async () => {\n        const structuredResponse: SignTypedDataResponse =\n          (await this.underlying.request(args)) as SignTypedDataResponse;\n        logger.web3.provider.debug(\"structuredResponse\", structuredResponse);\n\n        if (structuredResponse.status !== \"SUCCESS\") {\n          throw new Error(\"Metakeep Error: \" + structuredResponse.status);\n        }\n\n        return structuredResponse.signature;\n      };\n\n      // Use the analytics middleware if this is a tracked method\n      if (eventType) {\n        return withAnalytics(handleSignTypedData, eventType, \"ethereum\", [\n          args,\n        ] as const)();\n      }\n\n      return handleSignTypedData();\n    }\n\n    // Handle other methods\n    const handleOtherMethods = async () => {\n      logger.web3.provider.debug(\"EIP1193ProviderImpl: request\", args);\n      const result = await this.underlying.request(args);\n      logger.web3.provider.debug(\"EIP1193ProviderImpl: request result\", result);\n      return result;\n    };\n\n    // Use the analytics middleware if this is a tracked method\n    if (eventType) {\n      return withAnalytics(handleOtherMethods, eventType, \"ethereum\", [\n        args,\n      ] as const)();\n    }\n\n    return handleOtherMethods();\n  }\n\n  disconnect() {\n    this.localEventEmitter.emit(\n      \"disconnect\",\n      new ProviderRpcError(new Error(\"Disconnected by user\"), {\n        shortMessage: \"Disconnected by user\",\n        code: 4900,\n      }),\n    );\n  }\n\n  // EIP-1193 style event handling\n  on<Event extends keyof EIP1193EventMap>(\n    event: Event,\n    listener: EIP1193EventMap[Event],\n  ): void {\n    // If the `underlying` supports events. Otherwise rely on localEventEmitter.\n    if (isEventHandler(this.underlying)) {\n      // cast to a typed event handler here - even if the underlying is untyped.\n      (this.underlying as unknown as EIP1193Events).on(event, listener);\n    } else {\n      this.localEventEmitter.on(\n        event,\n        // the hard cast is needed here to avoid a type error between two ostensibly identical types\n        listener as Parameters<typeof this.localEventEmitter.on>[1],\n      );\n    }\n  }\n\n  removeListener<Event extends keyof EIP1193EventMap>(\n    event: Event,\n    listener: EIP1193EventMap[Event],\n  ): void {\n    // If the `underlying` supports events. Otherwise rely on localEventEmitter.\n    if (isEventHandler(this.underlying)) {\n      this.underlying.removeListener(event, listener);\n    } else {\n      // the hard cast is needed here to avoid a type error between two ostensibly identical types\n      this.localEventEmitter.removeListener(\n        event,\n        listener as Parameters<typeof this.localEventEmitter.removeListener>[1],\n      );\n    }\n  }\n}\n"]}