import { mergeObjectArrayWithoutDuplicates } from "../utils.js";
import { logger } from "../logger.js";
const eip2255Methods = [
    "wallet_getPermissions",
    "wallet_requestPermissions",
    // ERC-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
];
export class EIP2255ProviderImpl {
    permissionsStore = {};
    // Single implementation
    // We define the implementation this way so that the class can implement
    // the EIP2255Provider interface, which
    // requires a generic request method
    async request(args) {
        logger.web3.provider.debug("EIP2255ProviderImpl request args", args);
        const { method, params = [] } = args;
        switch (method) {
            case "wallet_getPermissions": {
                return Object.values(this.permissionsStore);
            }
            case "wallet_requestPermissions":
            case "wallet_grantPermissions": {
                const requested = params[0];
                for (const key of Object.keys(requested)) {
                    // construct the caveats array
                    const requestedElement = requested[key];
                    const requestedCaveatsArray = Object.entries(requestedElement ?? {}).map(([type, value]) => ({ type, value }));
                    // is there already a permission for this key?
                    const existingPermission = this.permissionsStore[key];
                    if (existingPermission) {
                        // if so, update it
                        this.permissionsStore[key] = {
                            ...existingPermission,
                            caveats: mergeObjectArrayWithoutDuplicates(existingPermission.caveats, requestedCaveatsArray, (a, b) => a.type === b.type && a.value === b.value),
                        };
                    }
                    else {
                        // otherwise, create a new permission
                        this.permissionsStore[key] = {
                            parentCapability: key,
                            caveats: requestedCaveatsArray,
                        };
                    }
                }
                return Object.values(this.permissionsStore);
            }
            case "wallet_revokePermissions": {
                const requested = params[0];
                for (const key of Object.keys(requested)) {
                    // is there already a permission for this key?
                    const existingPermission = this.permissionsStore[key];
                    if (existingPermission) {
                        // if so, remove it
                        delete this.permissionsStore[key];
                    }
                }
                return Object.values(this.permissionsStore);
            }
        }
        // If the method is not recognized, throw an error
        throw new Error(`Method not supported: ${method}`);
    }
}
/**
 * Given an eip1193 provider, augment it to support EIP-2255 methods
 * @param underlying - an EIP-1193 provider that has a `request` method
 * @returns a provider that supports EIP-2255 methods alongside EIP-1193 methods
 */
export const wrapWithEIP2255 = (underlying) => {
    const eip2255Impl = new EIP2255ProviderImpl();
    return new Proxy(underlying, {
        get(target, prop, receiver) {
            // If the property is one of the EIP-2255 methods, call eip2255Impl, otherwise call the underlying provider
            if (prop === "request") {
                return function (args) {
                    logger.web3.provider.debug("wrapWithEIP2255 proxy args", args);
                    const { method, params } = args;
                    if (eip2255Methods.includes(method)) {
                        return eip2255Impl.request({
                            method: method,
                            params,
                        });
                    }
                    else {
                        // Otherwise pass to underlying
                        return target.request(args);
                    }
                };
            }
            // Fallback for everything else
            return Reflect.get(target, prop, receiver);
        },
        set() {
            // Setting properties is not allowed
            throw new Error("Unauthorized operation");
        },
    });
};
//# sourceMappingURL=EIP2255Provider.js.map