import { describe, it, expect, vi } from "vitest";
import { createLazyProxy } from "./LazyProxy.js";
// A stub implementation of an EIP1193 provider. Emits events of type TestEventMap
class StubProvider {
    on = vi.fn();
    removeListener = vi.fn();
    request = vi.fn();
}
describe("LazyProxy", () => {
    it("should create a lazy proxy with the correct methods", () => {
        const proxy = createLazyProxy(["request"]);
        expect(typeof proxy.setImplementation).toBe("function");
        expect(typeof proxy.ready).toBe("function");
        expect(typeof proxy.on).toBe("function");
        expect(typeof proxy.removeListener).toBe("function");
    });
    it("should return false for ready() before implementation is set", () => {
        const proxy = createLazyProxy(["request"]);
        expect(proxy.ready()).toBe(false);
    });
    it("should return true for ready() after implementation is set", () => {
        const proxy = createLazyProxy(["request"]);
        const mockImpl = new StubProvider();
        proxy.setImplementation(mockImpl);
        expect(proxy.ready()).toBe(true);
    });
    it("should forward calls to setImplementation", () => {
        const proxy = createLazyProxy(["request"]);
        const mockImpl = new StubProvider();
        proxy.setImplementation(mockImpl);
        expect(proxy.ready()).toBe(true);
        expect(proxy.request).toBe(mockImpl.request);
    });
    it("should throw an error when accessing unknown methods before implementation is set", () => {
        const proxy = createLazyProxy(["request"]);
        expect(() => proxy.request({ method: "testMethod" })).toThrowError('Lazy proxy: Method "request" cannot be called because the implementation is not set yet.');
    });
    it("should store event listeners before the implementation is set", () => {
        const proxy = createLazyProxy(["request"]);
        const listener = vi.fn();
        proxy.on("dataReceived", listener);
        expect(proxy.ready()).toBe(false); // Still lazy, not set yet
    });
    it("should forward stored listeners to the real implementation once set", () => {
        const proxy = createLazyProxy(["request"]);
        const mockImpl = new StubProvider();
        const listener = vi.fn();
        proxy.on("dataReceived", listener);
        proxy.setImplementation(mockImpl);
        expect(mockImpl.on).toHaveBeenCalledWith("dataReceived", listener);
    });
    it("should store and remove listeners correctly before implementation is set", () => {
        const proxy = createLazyProxy(["request"]);
        const listener = vi.fn();
        proxy.on("dataReceived", listener);
        proxy.removeListener("dataReceived", listener);
        expect(() => proxy.setImplementation(new StubProvider())).not.toThrow();
    });
    it("should forward removeListener calls to the real implementation once set", () => {
        const proxy = createLazyProxy(["request"]);
        const mockImpl = new StubProvider();
        const listener = vi.fn();
        proxy.setImplementation(mockImpl);
        proxy.on("dataReceived", listener);
        proxy.removeListener("dataReceived", listener);
        expect(mockImpl.removeListener).toHaveBeenCalledWith("dataReceived", listener);
    });
    it("should return undefined for unknown properties before implementation is set", () => {
        const proxy = createLazyProxy([
            "request",
        ]);
        expect(proxy.someUndefinedMethod).toBeUndefined();
    });
    it("should allow unsetting the implementation", () => {
        const proxy = createLazyProxy(["request"]);
        const mockImpl = new StubProvider();
        proxy.setImplementation(mockImpl);
        expect(proxy.ready()).toBe(true);
        proxy.clearImplementation();
        expect(proxy.ready()).toBe(false);
    });
});
//# sourceMappingURL=LazyProxy.test.js.map