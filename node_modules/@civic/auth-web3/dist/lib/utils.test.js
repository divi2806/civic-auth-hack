import { describe, it, expect, vi, beforeEach } from "vitest";
import { errorMessage, mergeWithDefault, getCookie } from "./utils.js";
describe("mergeWithDefault", () => {
    it("should return default object when override is undefined", () => {
        const defaultObj = { a: 1, b: 2 };
        const result = mergeWithDefault(defaultObj, undefined);
        expect(result).toStrictEqual(defaultObj);
    });
    it("should merge objects keeping non-null values from override", () => {
        const defaultObj = { a: 1, b: 2, c: 3 };
        const overrideObj = { a: 4, b: undefined, c: undefined };
        const result = mergeWithDefault(defaultObj, overrideObj);
        expect(result).toStrictEqual({ a: 4, b: 2, c: 3 });
    });
    it("should handle empty override object", () => {
        const defaultObj = { a: 1, b: 2 };
        const overrideObj = {};
        const result = mergeWithDefault(defaultObj, overrideObj);
        expect(result).toStrictEqual(defaultObj);
    });
    it("should handle complex nested objects", () => {
        const defaultObj = {
            a: 1,
            nested: { x: 1, y: 2 },
        };
        const overrideObj = {
            a: undefined,
            nested: { x: 3, y: 4 },
        };
        const result = mergeWithDefault(defaultObj, overrideObj);
        // Note: Nested objects are replaced entirely, not merged deeply
        expect(result).toStrictEqual({
            a: 1,
            nested: { x: 3, y: 4 },
        });
    });
});
describe("errorMessage", () => {
    it("should return the message from an Error object", () => {
        const error = new Error("Test error message");
        expect(errorMessage(error)).toBe("Test error message");
    });
    it("should return the string if error is a string", () => {
        expect(errorMessage("String error message")).toBe("String error message");
    });
    it("should return undefined for non-string, non-error values", () => {
        expect(errorMessage(42)).toBeUndefined();
        expect(errorMessage(null)).toBeUndefined();
        expect(errorMessage({})).toBeUndefined();
        expect(errorMessage(undefined)).toBeUndefined();
    });
});
describe("getCookie", () => {
    beforeEach(() => {
        const mockDocument = {
            cookie: "testCookie=testValue; otherCookie=otherValue",
        };
        vi.stubGlobal("document", mockDocument);
    });
    it("should get existing cookie value", () => {
        expect(getCookie("testCookie")).toBe("testValue");
    });
    it("should return null for non-existent cookie", () => {
        expect(getCookie("nonExistentCookie")).toBe(null);
    });
    it("should handle multiple cookies with similar names", () => {
        vi.stubGlobal("document", {
            cookie: "test=value1; testCookie=value2; testCookieExtra=value3",
        });
        expect(getCookie("testCookie")).toBe("value2");
    });
    it("should handle cookies with special characters", () => {
        vi.stubGlobal("document", {
            cookie: "testCookie=value%20with%20spaces; otherCookie=value",
        });
        expect(getCookie("testCookie")).toBe("value%20with%20spaces");
    });
    it("should return null when document is undefined", () => {
        vi.stubGlobal("document", undefined);
        expect(getCookie("testCookie")).toBe(null);
    });
    it("should handle empty cookie string", () => {
        vi.stubGlobal("document", { cookie: "" });
        expect(getCookie("testCookie")).toBe(null);
    });
    it("should handle cookies with equals signs in the value", () => {
        vi.stubGlobal("document", {
            cookie: "testCookie=key=value; otherCookie=value",
        });
        expect(getCookie("testCookie")).toBe("key=value");
    });
    it("should handle cookies with no value", () => {
        vi.stubGlobal("document", {
            cookie: "testCookie=; otherCookie=value",
        });
        expect(getCookie("testCookie")).toBe("");
    });
});
//# sourceMappingURL=utils.test.js.map