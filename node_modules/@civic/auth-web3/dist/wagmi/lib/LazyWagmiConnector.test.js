import { describe, it, expect, vi, beforeEach } from "vitest";
import { injected } from "@wagmi/connectors";
import {} from "wagmi";
import { LazyWagmiConnector, embeddedWallet, } from "./LazyWagmiConnector.js";
import { web3Events } from "../../lib/Web3Client.js";
import { createTypedProvider, singletonEthereumProvider, } from "../../lib/ethereum/index.js";
const dummyTypedProvider = {
    on: vi.fn(),
    removeListener: vi.fn(),
    request: vi.fn(),
    disconnect: vi.fn(),
};
vi.mock("@wagmi/connectors");
describe("LazyWagmiConnector", () => {
    let connectorFn;
    beforeEach(() => {
        vi.mocked(injected).mockReturnValue((() => ({
            id: "civic",
            name: "Civic Wallet",
            disconnect: vi.fn(),
        })));
        connectorFn = LazyWagmiConnector({ debug: true });
        singletonEthereumProvider.clearImplementation();
    });
    it("should create a Wagmi connector", () => {
        expect(injected).toHaveBeenCalledWith(expect.objectContaining({
            target: expect.objectContaining({
                id: "civic",
                name: "Civic Wallet",
            }),
        }));
    });
    it("should listen to web3 events indicating when the provider is ready", () => {
        const lazyProvider = singletonEthereumProvider;
        const connector = connectorFn({
            emitter: { emit: vi.fn() },
        });
        expect(lazyProvider.ready()).toBe(false);
        web3Events.emit("web3ClientReady", {
            ethereum: {
                provider: dummyTypedProvider,
            },
        });
        expect(lazyProvider.ready()).toBe(true);
        expect(connector.ready()).toBe(true);
    });
    it("should disconnect the connector when the provider disconnects", () => {
        const providerImpl = createTypedProvider({
            request: vi.fn().mockResolvedValue(undefined),
        });
        // create a connector with a disconnect function
        const connector = connectorFn({
            emitter: { emit: vi.fn() },
        });
        // register the provider in the connector
        web3Events.emit("web3ClientReady", {
            ethereum: {
                provider: providerImpl,
            },
        });
        // disconnect the provider
        providerImpl.disconnect();
        // ensure the connector disconnect function was called
        expect(connector.disconnect).toHaveBeenCalled();
    });
    it("should allow setting the provider later", async () => {
        const connector = connectorFn({
            emitter: { emit: vi.fn() },
        });
        expect(connector.ready()).toBe(false);
        await connector.setProvider(dummyTypedProvider);
        expect(connector.ready()).toBe(true);
    });
    // this is needed so that wagmi does not think the wallet is still active
    it("should clear the provider when it disconnects", async () => {
        const connector = connectorFn({
            emitter: { emit: vi.fn() },
        });
        const provider = createTypedProvider({
            request: vi.fn().mockResolvedValue(undefined),
        });
        await connector.setProvider(provider);
        // disconnect the provider
        provider.disconnect();
        expect(connector.ready()).toBe(false);
    });
    describe("embeddedWallet()", () => {
        it("should create a connector with default config", () => {
            const embedded = embeddedWallet();
            expect(embedded).toBeInstanceOf(Function);
        });
        it("should allow overriding config options", () => {
            const embedded = embeddedWallet({ debug: true });
            expect(embedded).toBeInstanceOf(Function);
        });
    });
});
//# sourceMappingURL=LazyWagmiConnector.test.js.map