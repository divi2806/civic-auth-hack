{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Address, Chain, WalletClient } from \"viem\";\nimport type { User } from \"@civic/auth\";\nimport type {\n  CivicAuthProviderProps,\n  UserContextType,\n} from \"@civic/auth/react\";\nimport type { AuthProviderProps as NextCivicAuthProviderProps } from \"@civic/auth/nextjs\";\nimport type {\n  WalletAdapterProps,\n  MessageSignerWalletAdapterProps,\n  SignerWalletAdapterProps,\n  SignInMessageSignerWalletAdapterProps,\n} from \"@solana/wallet-adapter-base\";\n\nexport type NextCivicAuthWeb3ProviderProps = Omit<\n  NextCivicAuthProviderProps,\n  \"redirectUri\" | \"endpoints\"\n> &\n  Web3ProviderProps & { onSessionEnd?: () => void };\n\nexport type CivicAuthWeb3ProviderProps = Omit<\n  CivicAuthProviderProps,\n  \"redirectUri\" | \"endpoints\"\n> &\n  Web3ProviderProps & { onSessionEnd?: () => void };\n\nexport type Web3ProviderProps = {\n  autoCreateWallet?: boolean;\n  autoConnectEmbeddedWallet?: boolean;\n  endpoints?: {\n    auth?: string;\n    token?: string;\n    wallet?: string;\n    rpcs?: EVMChainRpcUrls;\n  };\n  chains?: Chain[];\n  initialChain?: Chain; // defaults to baseSepolia\n};\n\nexport type CivicWeb3ClientConfig = {\n  endpoints?: {\n    wallet?: string;\n    analytics?: string;\n    rpcs?: EVMChainRpcUrls;\n  };\n  chains?: Chain[];\n  initialChain?: Chain;\n};\n\nexport type ChainType = \"ethereum\" | \"solana\";\n\nexport type SparseWallet = {\n  walletAddress: string;\n  type: ChainType;\n};\nexport type GetWalletsResponse = SparseWallet[];\n\nexport type SolanaWallet = WalletAdapterProps<\"Civic\"> &\n  MessageSignerWalletAdapterProps<\"Civic\"> &\n  SignerWalletAdapterProps<\"Civic\"> &\n  SignInMessageSignerWalletAdapterProps<\"Civic\">;\n\nexport type UnknownObject = Record<string, unknown>;\nexport type Wallets = {\n  ethereum: {\n    address: Address;\n    wallet: WalletClient;\n  };\n  solana: {\n    address: string;\n    wallet: SolanaWallet;\n  };\n};\n\ntype BaseContext<T extends UnknownObject> = UserContextType & {\n  walletCreationInProgress: boolean;\n  user: User<T> | null;\n};\nexport type ExistingWeb3UserContext<T extends UnknownObject = UnknownObject> =\n  BaseContext<T> & Wallets;\n\nexport type NewWeb3UserContext<T extends UnknownObject = UnknownObject> =\n  BaseContext<T> & {\n    createWallet: () => Promise<void>;\n    walletCreationInProgress: boolean;\n    walletCreationAllowed?: boolean;\n  };\n\nexport type Web3UserContextType<T extends UnknownObject = UnknownObject> =\n  | NewWeb3UserContext<T>\n  | ExistingWeb3UserContext<T>;\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\nexport type RpcUrls = {\n  http: NonEmptyArray<string>;\n  webSocket?: NonEmptyArray<string> | undefined;\n};\n\nexport type EVMChainRpcUrls = Record<number, RpcUrls>;\n\n// This is a simplified version of an EIP1193Provider type, used by Metakeep, and in places by Viem\nexport type GenericEthereumProvider = {\n  request(...args: unknown[]): Promise<unknown>;\n};\n\n// The details that a user needs to provide in order to be usable for embedded wallets\nexport type UserDetails = {\n  // needed to map to a wallet in metakeep\n  email: string;\n  // if the wallet claims are present, we use it to determine the wallet address\n  ethWalletAddress?: string;\n  solWalletAddress?: string;\n};\n\n// this is not particularly neat - the idToken could be part of UserDetails, but is only stored inside the user\n// in order to pass into the web3 client interface. Perhaps a better solution is to change the wallet client\n// interface to look for user-specific auth features in a separate object.\n// However, combining all user-specific data into a single User object is neater in general from the perspective\n// of the web3 client interface.\nexport type UserDetailsWithAuth = UserDetails & {\n  idToken: string;\n};\n\nexport type PermissionsCheckResponse = {\n  [key: string]: {\n    allowed: boolean;\n    reason?: string;\n  };\n};\n"]}