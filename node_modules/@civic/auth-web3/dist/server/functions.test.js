/* eslint-disable @typescript-eslint/no-explicit-any */
import { describe, it, expect, vi, beforeEach } from "vitest";
import { getUser } from "./functions.js";
import { MetakeepServerWeb3Client, } from "../lib/metakeep/MetakeepServerWeb3Client.js";
const mockWeb3Client = { createWallets: vi.fn() };
// Mock CivicAuth
vi.mock("@civic/auth/server", () => ({
    CivicAuth: vi.fn().mockImplementation(() => ({
        getUser: vi.fn(),
        getTokens: vi.fn(),
    })),
}));
vi.mock("metakeep");
vi.mock("../lib/metakeep/MetakeepServerWeb3Client.js");
// Mock getWallets function
vi.mock("./functions.js", async (importOriginal) => {
    const actual = await importOriginal();
    return {
        ...actual,
        // We need to keep the actual functions we're testing
        getUser: actual.getUser,
        getUserWithAuthDetails: actual
            .getUserWithAuthDetails,
    };
});
describe("getUser", () => {
    const mockAuthStorage = {};
    const mockAuthConfig = {};
    const mockConfig = {};
    beforeEach(async () => {
        vi.mocked(MetakeepServerWeb3Client.build).mockResolvedValue({
            ...mockWeb3Client,
            ethereum: { address: "mock-eth-address" },
            solana: { address: "mock-sol-address" },
        });
        mockWeb3Client.createWallets.mockResolvedValue({
            ethereum: "mock-eth-address",
            solana: "mock-sol-address",
        });
    });
    // Create a mock user with basic auth details
    const mockUser = {
        id: "user-123",
        email: "test@example.com",
        idToken: "mock-id-token",
    };
    // Import CivicAuth for mocking
    let CivicAuth;
    let mockCivicAuth;
    beforeEach(async () => {
        vi.clearAllMocks();
        const { CivicAuth: CivicAuthImported } = await import("@civic/auth/server");
        CivicAuth = CivicAuthImported;
        mockCivicAuth = {
            getUser: vi.fn(),
            getTokens: vi.fn(),
        };
        // Reset the mocks
        CivicAuth.mockImplementation(() => mockCivicAuth);
        mockCivicAuth.getUser.mockResolvedValue({
            id: mockUser.id,
            email: mockUser.email,
        });
        mockCivicAuth.getTokens.mockResolvedValue({ idToken: mockUser.idToken });
    });
    it("should return null if user is not authenticated", async () => {
        // Simulate user not being authenticated
        mockCivicAuth.getUser.mockResolvedValue(null);
        const result = await getUser(mockConfig, mockAuthStorage, mockAuthConfig);
        expect(result).toBeNull();
        expect(CivicAuth).toHaveBeenCalledWith(mockAuthStorage, mockAuthConfig);
        expect(mockCivicAuth.getUser).toHaveBeenCalled();
    });
    it("should correctly add only ethereum wallet address to user object", async () => {
        mockWeb3Client.createWallets.mockResolvedValue({
            ethereum: "mock-eth-address",
            solana: null,
        });
        vi.mocked(MetakeepServerWeb3Client.build).mockResolvedValue({
            ...mockWeb3Client,
            ethereum: { address: "mock-eth-address" },
            solana: null,
        });
        const result = await getUser(mockConfig, mockAuthStorage, mockAuthConfig);
        expect(result).not.toBeNull();
        expect(result).toEqual({
            ...mockUser,
            ethereum: {
                address: "mock-eth-address",
            },
        });
        expect(CivicAuth).toHaveBeenCalledWith(mockAuthStorage, mockAuthConfig);
        expect(mockCivicAuth.getUser).toHaveBeenCalled();
        expect(mockCivicAuth.getTokens).toHaveBeenCalled();
    });
    it("should correctly add only solana wallet address to user object", async () => {
        mockWeb3Client.createWallets.mockResolvedValue({
            ethereum: null,
            solana: "mock-sol-address",
        });
        vi.mocked(MetakeepServerWeb3Client.build).mockResolvedValue({
            ...mockWeb3Client,
            ethereum: null,
            solana: { address: "mock-sol-address" },
        });
        const result = await getUser(mockConfig, mockAuthStorage, mockAuthConfig);
        expect(result).not.toBeNull();
        expect(result).toEqual({
            ...mockUser,
            solana: {
                address: "mock-sol-address",
            },
        });
        expect(CivicAuth).toHaveBeenCalledWith(mockAuthStorage, mockAuthConfig);
        expect(mockCivicAuth.getUser).toHaveBeenCalled();
        expect(mockCivicAuth.getTokens).toHaveBeenCalled();
    });
    it("should correctly add both ethereum and solana wallet addresses to user object", async () => {
        // Mock the getWallets to return both ethereum and solana wallets
        const result = await getUser(mockConfig, mockAuthStorage, mockAuthConfig);
        expect(result).not.toBeNull();
        expect(result).toEqual({
            ...mockUser,
            ethereum: {
                address: "mock-eth-address",
            },
            solana: {
                address: "mock-sol-address",
            },
        });
        expect(CivicAuth).toHaveBeenCalledWith(mockAuthStorage, mockAuthConfig);
        expect(mockCivicAuth.getUser).toHaveBeenCalled();
        expect(mockCivicAuth.getTokens).toHaveBeenCalled();
    });
    it("should handle empty wallets list gracefully", async () => {
        mockWeb3Client.createWallets.mockResolvedValue({
            ethereum: null,
            solana: null,
        });
        vi.mocked(MetakeepServerWeb3Client.build).mockResolvedValue({
            ...mockWeb3Client,
            ethereum: null,
            solana: null,
        });
        const result = await getUser(mockConfig, mockAuthStorage, mockAuthConfig);
        expect(result).not.toBeNull();
        expect(result).toEqual({
            ...mockUser,
            solana: undefined,
            ethereum: undefined,
        });
        expect(CivicAuth).toHaveBeenCalledWith(mockAuthStorage, mockAuthConfig);
        expect(mockCivicAuth.getUser).toHaveBeenCalled();
        expect(mockCivicAuth.getTokens).toHaveBeenCalled();
    });
});
//# sourceMappingURL=functions.test.js.map