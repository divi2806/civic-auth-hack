"use client";
import { useToken, useUser as useUserInternal, } from "@civic/auth/react";
import React, { createContext, useCallback, useContext, useEffect, useMemo, } from "react";
import { useCreateWallets } from "../hooks/useCreateWallets.js";
import { AuthStatus } from "@civic/auth";
import {} from "../types.js";
import { useWeb3Client } from "../hooks/metakeep/useWeb3Client.js";
import { useTriggerSigninOnWalletConnection } from "../hooks/useTriggerSigninOnWalletConnection.js";
import { useAnalyticsWithAuth } from "../hooks/useAnalyticsWithAuth.js";
import { useState } from "react";
// The Web3UserProvider component is a wrapper around the CivicAuthProvider component that provides
// an augmented user object to the rest of the application, with web3 wallet information.
// If the user already has an embedded wallet, the wallet address and viem client are added to the user object.
// NOTE: When using wagmi, these augmented user fields are not necessary, as the wagmi connector
// provides the same information and can be directly injected into the wagmi config
// If the user does not yet have an embedded wallet, a createWallet function is added to the user object.
const defaultContext = {
    displayMode: "iframe",
    isAuthenticated: false,
    isLoading: false,
    error: null,
    isSigningOut: false,
    signIn: () => {
        throw new Error("signIn not implemented");
    },
    signOut: () => {
        throw new Error("signOut not implemented");
    },
    user: null,
    walletAddress: null,
    wallet: null,
    createWallet: () => {
        throw new Error("createWallet not implemented");
    },
    walletCreationInProgress: false,
    walletCreationAllowed: undefined,
    authStatus: AuthStatus.UNAUTHENTICATED,
};
const Web3UserContext = createContext(defaultContext);
export const useUser = () => useContext(Web3UserContext);
export const Web3UserProvider = ({ children, registerLogoutCallback, ...props }) => {
    const internalUserContext = useUserInternal();
    const tokens = useToken();
    const [walletCreationAllowed, setWalletCreationAllowed] = useState(undefined);
    // we need to sign out of the civic auth provider when the user signs out of the web3 wallet
    // however, as the user can also be signed out via the civic auth provider, we don't
    // want to create a loop here, so we make sure the user is authenticated before trying
    const doSignOut = useCallback(() => {
        if (internalUserContext.authStatus !== AuthStatus.AUTHENTICATED) {
            return;
        }
        return internalUserContext.signOut();
    }, [internalUserContext.authStatus]);
    const web3Client = useWeb3Client(props, doSignOut);
    // if a wallet connector UI is being used, this will trigger a sign in when the user selects the civic wallets
    useTriggerSigninOnWalletConnection();
    // Set up analytics to include the user's authentication token
    useAnalyticsWithAuth();
    const { createWallet, walletCreationInProgress } = useCreateWallets(web3Client);
    // Note: We no longer need to check wallet creation permissions here
    // as the permission check is now performed in the Web3Client.build method
    // We'll keep the state for future use if needed
    useEffect(() => {
        if (internalUserContext.authStatus !== AuthStatus.AUTHENTICATED) {
            // Reset when user logs out
            setWalletCreationAllowed(undefined);
        }
    }, [internalUserContext.authStatus]);
    // register the logout callback
    useEffect(() => {
        if (web3Client) {
            registerLogoutCallback(() => web3Client.disconnect());
        }
    }, [web3Client, registerLogoutCallback]);
    const web3User = useMemo(() => {
        const isAuthenticated = !!internalUserContext.user;
        const authContext = {
            signIn: internalUserContext.signIn,
            authStatus: internalUserContext.authStatus,
            isAuthenticated,
            isLoading: internalUserContext.isLoading,
            error: internalUserContext.error,
            signOut: internalUserContext.signOut,
            displayMode: internalUserContext.displayMode,
        };
        if (!web3Client) {
            return {
                ...authContext,
                ...tokens,
                // we override the civic auth isLoading state as we're still loading until we have a web3 client
                isLoading: !!internalUserContext?.user,
                user: null,
                createWallet,
                walletCreationInProgress,
            };
        }
        // we don't have an address so we're a new user and need to expose the createWallet function
        if (!web3Client.ethereum?.address && !web3Client.solana?.address) {
            return {
                ...authContext,
                ...tokens,
                isLoading: false,
                createWallet,
                user: internalUserContext.user,
                walletCreationInProgress,
                walletCreationAllowed,
            };
        }
        // this is an existing user with a wallet
        return {
            ...authContext,
            ...tokens,
            isLoading: false,
            ethereum: {
                address: web3Client.ethereum.address,
                wallet: web3Client.ethereum.client,
            },
            solana: {
                address: web3Client.solana.address,
                wallet: web3Client.solana.wallet,
            },
            user: internalUserContext.user,
            walletCreationInProgress,
        };
    }, [
        internalUserContext.user,
        createWallet,
        web3Client?.ethereum.address,
        web3Client?.solana.address,
        walletCreationAllowed,
        tokens,
        internalUserContext.authStatus,
        internalUserContext.isLoading,
        internalUserContext.error,
        internalUserContext.signIn,
        internalUserContext.signOut,
        internalUserContext.displayMode,
        walletCreationInProgress,
    ]);
    return (React.createElement(Web3UserContext.Provider, { value: web3User }, children));
};
//# sourceMappingURL=Web3UserProvider.js.map