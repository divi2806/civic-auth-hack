/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/**
 * @jest-environment jsdom
 */
import { vi, beforeEach } from "vitest";
import {} from "../types.js";
import {} from "../lib/Web3Client.js";
// Note: We need to set up the mocks BEFORE importing the components
// Vitest hoists vi.mock calls to the top of the file
// Setup mock functions
const mockSignIn = vi.fn();
const mockSignOut = vi.fn();
const mockCreateWallet = vi.fn().mockResolvedValue(undefined);
const mockDisconnect = vi.fn().mockResolvedValue(undefined);
const mockCreateWallets = vi.fn().mockResolvedValue(null);
// Create mock implementations of the required interfaces
const createMockEthereumClient = (address) => ({
    address,
    client: address ? {} : null,
    provider: {},
    disconnect: mockDisconnect,
});
const createMockSolanaClient = (address) => ({
    address: address, // TypeScript trick to satisfy the readonly property
    wallet: address ? {} : null,
    disconnect: mockDisconnect,
});
const createMockWeb3Client = (ethAddress = null, solAddress = null) => ({
    ethereum: createMockEthereumClient(ethAddress),
    solana: createMockSolanaClient(solAddress),
    connected: true,
    createWallets: mockCreateWallets,
    disconnect: mockDisconnect,
});
// Initialize mock data
let mockUserData = {
    user: null,
    signIn: mockSignIn,
    signOut: mockSignOut,
    authStatus: "UNAUTHENTICATED",
    isAuthenticated: false,
    isLoading: false,
    error: null,
    displayMode: "iframe",
};
let mockWeb3ClientData = null;
// Mock dependencies
vi.mock("@civic/auth/react", () => ({
    useToken: () => ({
        token: "mock-token",
        idToken: "mock-id-token",
    }),
    useUser: () => mockUserData,
}));
vi.mock("../hooks/useCreateWallets.js", () => ({
    useCreateWallets: () => ({
        createWallet: mockCreateWallet,
        walletCreationInProgress: false,
        error: null,
        createWalletFinished: false,
    }),
}));
vi.mock("../hooks/metakeep/useWeb3Client.js", () => ({
    useWeb3Client: (props, doSignOut) => {
        // If mockWeb3ClientData is a function, call it with doSignOut
        if (typeof mockWeb3ClientData === "function") {
            return mockWeb3ClientData(props, doSignOut);
        }
        return mockWeb3ClientData;
    },
}));
vi.mock("../hooks/useTriggerSigninOnWalletConnection.js", () => ({
    useTriggerSigninOnWalletConnection: () => undefined,
}));
// NOW import everything else
import { describe, it, expect } from "vitest";
import { render, screen } from "@testing-library/react";
import "@testing-library/jest-dom";
import { Web3UserProvider, useUser } from "./Web3UserProvider.js";
import { AuthStatus } from "@civic/auth";
import React from "react";
// Test component that accesses the Web3UserContext
const TestComponent = () => {
    const user = useUser();
    return (React.createElement("div", null,
        React.createElement("div", { "data-testid": "auth-status" }, user.authStatus),
        React.createElement("div", { "data-testid": "is-authenticated" }, String(user.authStatus === AuthStatus.AUTHENTICATED)),
        React.createElement("div", { "data-testid": "is-loading" }, String(user.isLoading)),
        React.createElement("div", { "data-testid": "wallet-creation-in-progress" }, String(user.walletCreationInProgress)),
        user.user && React.createElement("div", { "data-testid": "user-exists" }, "true"),
        "createWallet" in user && (React.createElement("button", { "data-testid": "create-wallet-button" }, "Create Wallet")),
        "ethereum" in user && user.ethereum?.address && (React.createElement("div", { "data-testid": "ethereum-address" }, user.ethereum.address)),
        "solana" in user && user.solana?.address && (React.createElement("div", { "data-testid": "solana-address" }, user.solana.address))));
};
describe("Web3UserProvider", () => {
    const mockRegisterLogoutCallback = vi.fn();
    beforeEach(() => {
        // Reset mock data to default values
        mockUserData = {
            user: null,
            signIn: mockSignIn,
            signOut: mockSignOut,
            authStatus: "UNAUTHENTICATED",
            isAuthenticated: false,
            isLoading: false,
            error: null,
            displayMode: "iframe",
        };
        mockWeb3ClientData = null;
        vi.clearAllMocks();
    });
    it("should render children", () => {
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement("div", { "data-testid": "child" }, "Child Component")));
        expect(screen.getByTestId("child")).toBeInTheDocument();
        expect(screen.getByTestId("child")).toHaveTextContent("Child Component");
    });
    it("should provide default context values when no web3client exists", () => {
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement(TestComponent, null)));
        expect(screen.getByTestId("auth-status")).toHaveTextContent("UNAUTHENTICATED");
        expect(screen.getByTestId("is-authenticated")).toHaveTextContent("false");
        expect(screen.getByTestId("is-loading")).toHaveTextContent("false");
        expect(screen.getByTestId("wallet-creation-in-progress")).toHaveTextContent("false");
        expect(screen.getByTestId("create-wallet-button")).toBeInTheDocument();
        expect(screen.getByTestId("create-wallet-button")).toHaveTextContent("Create Wallet");
    });
    it("should provide proper context when web3client exists but no wallet addresses", () => {
        // Setup authenticated user for this test
        mockUserData = {
            user: { id: "user-123", email: "test@example.com" },
            signIn: mockSignIn,
            signOut: mockSignOut,
            authStatus: AuthStatus.AUTHENTICATED,
            isAuthenticated: true,
            isLoading: false,
            error: null,
            displayMode: "iframe",
        };
        // Setup web3client without addresses
        mockWeb3ClientData = createMockWeb3Client(null, null);
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement(TestComponent, null)));
        expect(screen.getByTestId("auth-status")).toHaveTextContent(AuthStatus.AUTHENTICATED);
        expect(screen.getByTestId("is-authenticated")).toHaveTextContent("true");
        expect(screen.getByTestId("user-exists")).toBeInTheDocument();
        expect(screen.getByTestId("create-wallet-button")).toBeInTheDocument();
    });
    it("should provide existing wallet context when web3client includes addresses", () => {
        // Setup authenticated user for this test
        mockUserData = {
            user: { id: "user-123", email: "test@example.com" },
            signIn: mockSignIn,
            signOut: mockSignOut,
            authStatus: AuthStatus.AUTHENTICATED,
            isAuthenticated: true,
            isLoading: false,
            error: null,
            displayMode: "iframe",
        };
        // Setup web3client with wallet addresses
        mockWeb3ClientData = createMockWeb3Client("0x1234567890123456789012345678901234567890", "SoLAddrE5S111111111111111111111111111111111");
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement(TestComponent, null)));
        expect(screen.getByTestId("auth-status")).toHaveTextContent(AuthStatus.AUTHENTICATED);
        expect(screen.getByTestId("is-authenticated")).toHaveTextContent("true");
        expect(screen.getByTestId("ethereum-address")).toHaveTextContent("0x1234567890123456789012345678901234567890");
        expect(screen.getByTestId("solana-address")).toHaveTextContent("SoLAddrE5S111111111111111111111111111111111");
        expect(screen.queryByTestId("create-wallet-button")).not.toBeInTheDocument();
    });
    it("should register logout callback when web3client is available", () => {
        // Setup web3client with disconnect method
        mockWeb3ClientData = createMockWeb3Client(null, null);
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement(TestComponent, null)));
        // Check that the logout callback was registered
        expect(mockRegisterLogoutCallback).toHaveBeenCalledTimes(1);
        // Call the registered callback
        const registeredCallback = mockRegisterLogoutCallback.mock
            .calls[0]?.[0];
        registeredCallback();
        // Verify the web3client's disconnect was called
        expect(mockDisconnect).toHaveBeenCalledTimes(1);
    });
    it("should handle sign out correctly when authStatus is AUTHENTICATED", () => {
        const authMockSignOut = vi.fn();
        // Setup authenticated user with signOut function
        mockUserData = {
            user: { id: "user-123", email: "test@example.com" },
            signIn: mockSignIn,
            signOut: authMockSignOut,
            authStatus: AuthStatus.AUTHENTICATED,
            isAuthenticated: true,
            isLoading: false,
            error: null,
            displayMode: "iframe",
        };
        // Capture the doSignOut function passed to useWeb3Client
        let capturedDoSignOut = null;
        mockWeb3ClientData = (props, doSignOut) => {
            capturedDoSignOut = doSignOut || null;
            return createMockWeb3Client(null, null);
        };
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement(TestComponent, null)));
        // Call the doSignOut function that was captured
        if (capturedDoSignOut) {
            capturedDoSignOut();
        }
        // The signOut function should have been called because authStatus is AUTHENTICATED
        expect(authMockSignOut).toHaveBeenCalledTimes(1);
    });
    it("should not call signOut when authStatus is not AUTHENTICATED", () => {
        const authMockSignOut = vi.fn();
        // Setup unauthenticated user with signOut function
        mockUserData = {
            user: null,
            signIn: mockSignIn,
            signOut: authMockSignOut,
            authStatus: AuthStatus.UNAUTHENTICATED,
            isAuthenticated: false,
            isLoading: false,
            error: null,
            displayMode: "iframe",
        };
        // Capture the doSignOut function passed to useWeb3Client
        let capturedDoSignOut = null;
        mockWeb3ClientData = (props, doSignOut) => {
            capturedDoSignOut = doSignOut || null;
            return createMockWeb3Client(null, null);
        };
        render(React.createElement(Web3UserProvider, { registerLogoutCallback: mockRegisterLogoutCallback },
            React.createElement(TestComponent, null)));
        // Call the doSignOut function that was captured
        if (capturedDoSignOut) {
            capturedDoSignOut();
        }
        // The signOut function should NOT have been called because authStatus is UNAUTHENTICATED
        expect(authMockSignOut).not.toHaveBeenCalled();
    });
});
//# sourceMappingURL=Web3UserProvider.test.js.map