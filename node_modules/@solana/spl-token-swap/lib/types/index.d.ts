import type { ConfirmOptions, Connection, Keypair, TransactionSignature } from '@solana/web3.js';
import { PublicKey, TransactionInstruction } from '@solana/web3.js';
export declare const TOKEN_SWAP_PROGRAM_ID: PublicKey;
export declare const OLD_TOKEN_SWAP_PROGRAM_ID: PublicKey;
export interface RawTokenSwap {
    version: number;
    isInitialized: boolean;
    bumpSeed: number;
    poolTokenProgramId: PublicKey;
    tokenAccountA: PublicKey;
    tokenAccountB: PublicKey;
    tokenPool: PublicKey;
    mintA: PublicKey;
    mintB: PublicKey;
    feeAccount: PublicKey;
    tradeFeeNumerator: bigint;
    tradeFeeDenominator: bigint;
    ownerTradeFeeNumerator: bigint;
    ownerTradeFeeDenominator: bigint;
    ownerWithdrawFeeNumerator: bigint;
    ownerWithdrawFeeDenominator: bigint;
    hostFeeNumerator: bigint;
    hostFeeDenominator: bigint;
    curveType: number;
    curveParameters: Uint8Array;
}
export declare const TokenSwapLayout: import("@solana/buffer-layout").Structure<RawTokenSwap>;
export interface CreateInstruction {
    instruction: number;
    tradeFeeNumerator: bigint;
    tradeFeeDenominator: bigint;
    ownerTradeFeeNumerator: bigint;
    ownerTradeFeeDenominator: bigint;
    ownerWithdrawFeeNumerator: bigint;
    ownerWithdrawFeeDenominator: bigint;
    hostFeeNumerator: bigint;
    hostFeeDenominator: bigint;
    curveType: number;
    curveParameters: Uint8Array;
}
export interface SwapInstruction {
    instruction: number;
    amountIn: bigint;
    minimumAmountOut: bigint;
}
export interface DepositAllInstruction {
    instruction: number;
    poolTokenAmount: bigint;
    maximumTokenA: bigint;
    maximumTokenB: bigint;
}
export interface WithdrawAllInstruction {
    instruction: number;
    poolTokenAmount: bigint;
    minimumTokenA: bigint;
    minimumTokenB: bigint;
}
export interface DepositSingleTokenTypeInstruction {
    instruction: number;
    sourceTokenAmount: bigint;
    minimumPoolTokenAmount: bigint;
}
export interface WithdrawSingleTokenTypeInstruction {
    instruction: number;
    destinationTokenAmount: bigint;
    maximumPoolTokenAmount: bigint;
}
export declare const CurveType: Readonly<{
    ConstantProduct: 0;
    ConstantPrice: 1;
    Offset: 2;
}>;
/**
 * A program to exchange tokens against a pool of liquidity
 */
export declare class TokenSwap {
    private connection;
    tokenSwap: PublicKey;
    swapProgramId: PublicKey;
    poolTokenProgramId: PublicKey;
    poolToken: PublicKey;
    feeAccount: PublicKey;
    authority: PublicKey;
    tokenAccountA: PublicKey;
    tokenAccountB: PublicKey;
    mintA: PublicKey;
    mintB: PublicKey;
    tradeFeeNumerator: bigint;
    tradeFeeDenominator: bigint;
    ownerTradeFeeNumerator: bigint;
    ownerTradeFeeDenominator: bigint;
    ownerWithdrawFeeNumerator: bigint;
    ownerWithdrawFeeDenominator: bigint;
    hostFeeNumerator: bigint;
    hostFeeDenominator: bigint;
    curveType: number;
    payer: Keypair;
    /**
     * Create a Token object attached to the specific token
     *
     * @param connection The connection to use
     * @param tokenSwap The token swap account
     * @param swapProgramId The program ID of the token-swap program
     * @param poolTokenProgramId The program ID of the token program for the pool tokens
     * @param poolToken The pool token
     * @param authority The authority over the swap and accounts
     * @param tokenAccountA The token swap's Token A account
     * @param tokenAccountB The token swap's Token B account
     * @param mintA The mint of Token A
     * @param mintB The mint of Token B
     * @param tradeFeeNumerator The trade fee numerator
     * @param tradeFeeDenominator The trade fee denominator
     * @param ownerTradeFeeNumerator The owner trade fee numerator
     * @param ownerTradeFeeDenominator The owner trade fee denominator
     * @param ownerWithdrawFeeNumerator The owner withdraw fee numerator
     * @param ownerWithdrawFeeDenominator The owner withdraw fee denominator
     * @param hostFeeNumerator The host fee numerator
     * @param hostFeeDenominator The host fee denominator
     * @param curveType The curve type
     * @param payer Pays for the transaction
     */
    constructor(connection: Connection, tokenSwap: PublicKey, swapProgramId: PublicKey, poolTokenProgramId: PublicKey, poolToken: PublicKey, feeAccount: PublicKey, authority: PublicKey, tokenAccountA: PublicKey, tokenAccountB: PublicKey, mintA: PublicKey, mintB: PublicKey, tradeFeeNumerator: bigint, tradeFeeDenominator: bigint, ownerTradeFeeNumerator: bigint, ownerTradeFeeDenominator: bigint, ownerWithdrawFeeNumerator: bigint, ownerWithdrawFeeDenominator: bigint, hostFeeNumerator: bigint, hostFeeDenominator: bigint, curveType: number, payer: Keypair);
    /**
     * Get the minimum balance for the token swap account to be rent exempt
     *
     * @return Number of lamports required
     */
    static getMinBalanceRentForExemptTokenSwap(connection: Connection): Promise<number>;
    static createInitSwapInstruction(tokenSwapAccount: Keypair, authority: PublicKey, tokenAccountA: PublicKey, tokenAccountB: PublicKey, tokenPool: PublicKey, feeAccount: PublicKey, tokenAccountPool: PublicKey, poolTokenProgramId: PublicKey, swapProgramId: PublicKey, tradeFeeNumerator: bigint, tradeFeeDenominator: bigint, ownerTradeFeeNumerator: bigint, ownerTradeFeeDenominator: bigint, ownerWithdrawFeeNumerator: bigint, ownerWithdrawFeeDenominator: bigint, hostFeeNumerator: bigint, hostFeeDenominator: bigint, curveType: number, curveParameters?: Uint8Array): TransactionInstruction;
    static loadTokenSwap(connection: Connection, address: PublicKey, programId: PublicKey, payer: Keypair): Promise<TokenSwap>;
    /**
     * Create a new Token Swap
     *
     * @param connection The connection to use
     * @param payer Pays for the transaction
     * @param tokenSwapAccount The token swap account
     * @param authority The authority over the swap and accounts
     * @param tokenAccountA: The token swap's Token A account
     * @param tokenAccountB: The token swap's Token B account
     * @param poolToken The pool token
     * @param tokenAccountPool The token swap's pool token account
     * @param poolTokenProgramId The program ID of the token program for pool tokens
     * @param swapProgramId The program ID of the token-swap program
     * @param feeNumerator Numerator of the fee ratio
     * @param feeDenominator Denominator of the fee ratio
     * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens
     */
    static createTokenSwap(connection: Connection, payer: Keypair, tokenSwapAccount: Keypair, authority: PublicKey, tokenAccountA: PublicKey, tokenAccountB: PublicKey, poolToken: PublicKey, mintA: PublicKey, mintB: PublicKey, feeAccount: PublicKey, tokenAccountPool: PublicKey, swapProgramId: PublicKey, poolTokenProgramId: PublicKey, tradeFeeNumerator: bigint, tradeFeeDenominator: bigint, ownerTradeFeeNumerator: bigint, ownerTradeFeeDenominator: bigint, ownerWithdrawFeeNumerator: bigint, ownerWithdrawFeeDenominator: bigint, hostFeeNumerator: bigint, hostFeeDenominator: bigint, curveType: number, curveParameters?: Uint8Array, confirmOptions?: ConfirmOptions): Promise<TokenSwap>;
    /**
     * Swap token A for token B
     *
     * @param userSource User's source token account
     * @param poolSource Pool's source token account
     * @param poolDestination Pool's destination token account
     * @param userDestination User's destination token account
     * @param sourceMint Mint for the source token
     * @param destinationMint Mint for the destination token
     * @param sourceTokenProgramId Program id for the source token
     * @param destinationTokenProgramId Program id for the destination token
     * @param hostFeeAccount Host account to gather fees
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param amountIn Amount to transfer from source account
     * @param minimumAmountOut Minimum amount of tokens the user will receive
     */
    swap(userSource: PublicKey, poolSource: PublicKey, poolDestination: PublicKey, userDestination: PublicKey, sourceMint: PublicKey, destinationMint: PublicKey, sourceTokenProgramId: PublicKey, destinationTokenProgramId: PublicKey, hostFeeAccount: PublicKey | null, userTransferAuthority: Keypair, amountIn: bigint, minimumAmountOut: bigint, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
    static swapInstruction(tokenSwap: PublicKey, authority: PublicKey, userTransferAuthority: PublicKey, userSource: PublicKey, poolSource: PublicKey, poolDestination: PublicKey, userDestination: PublicKey, poolMint: PublicKey, feeAccount: PublicKey, hostFeeAccount: PublicKey | null, sourceMint: PublicKey, destinationMint: PublicKey, swapProgramId: PublicKey, sourceTokenProgramId: PublicKey, destinationTokenProgramId: PublicKey, poolTokenProgramId: PublicKey, amountIn: bigint, minimumAmountOut: bigint): TransactionInstruction;
    /**
     * Deposit tokens into the pool
     * @param userAccountA User account for token A
     * @param userAccountB User account for token B
     * @param poolAccount User account for pool token
     * @param tokenProgramIdA Program id for token A
     * @param tokenProgramIdB Program id for token B
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param poolTokenAmount Amount of pool tokens to mint
     * @param maximumTokenA The maximum amount of token A to deposit
     * @param maximumTokenB The maximum amount of token B to deposit
     */
    depositAllTokenTypes(userAccountA: PublicKey, userAccountB: PublicKey, poolAccount: PublicKey, tokenProgramIdA: PublicKey, tokenProgramIdB: PublicKey, userTransferAuthority: Keypair, poolTokenAmount: bigint, maximumTokenA: bigint, maximumTokenB: bigint, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
    static depositAllTokenTypesInstruction(tokenSwap: PublicKey, authority: PublicKey, userTransferAuthority: PublicKey, sourceA: PublicKey, sourceB: PublicKey, intoA: PublicKey, intoB: PublicKey, poolToken: PublicKey, poolAccount: PublicKey, mintA: PublicKey, mintB: PublicKey, swapProgramId: PublicKey, tokenProgramIdA: PublicKey, tokenProgramIdB: PublicKey, poolTokenProgramId: PublicKey, poolTokenAmount: bigint, maximumTokenA: bigint, maximumTokenB: bigint): TransactionInstruction;
    /**
     * Withdraw tokens from the pool
     *
     * @param userAccountA User account for token A
     * @param userAccountB User account for token B
     * @param poolAccount User account for pool token
     * @param tokenProgramIdA Program id for token A
     * @param tokenProgramIdB Program id for token B
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param poolTokenAmount Amount of pool tokens to burn
     * @param minimumTokenA The minimum amount of token A to withdraw
     * @param minimumTokenB The minimum amount of token B to withdraw
     */
    withdrawAllTokenTypes(userAccountA: PublicKey, userAccountB: PublicKey, poolAccount: PublicKey, tokenProgramIdA: PublicKey, tokenProgramIdB: PublicKey, userTransferAuthority: Keypair, poolTokenAmount: bigint, minimumTokenA: bigint, minimumTokenB: bigint, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
    static withdrawAllTokenTypesInstruction(tokenSwap: PublicKey, authority: PublicKey, userTransferAuthority: PublicKey, poolMint: PublicKey, feeAccount: PublicKey, sourcePoolAccount: PublicKey, fromA: PublicKey, fromB: PublicKey, userAccountA: PublicKey, userAccountB: PublicKey, mintA: PublicKey, mintB: PublicKey, swapProgramId: PublicKey, poolTokenProgramId: PublicKey, tokenProgramIdA: PublicKey, tokenProgramIdB: PublicKey, poolTokenAmount: bigint, minimumTokenA: bigint, minimumTokenB: bigint): TransactionInstruction;
    /**
     * Deposit one side of tokens into the pool
     * @param userAccount User account to deposit token A or B
     * @param poolAccount User account to receive pool tokens
     * @param sourceMint Mint for the source token
     * @param sourceTokenProgramId Program id for the source token
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param sourceTokenAmount The amount of token A or B to deposit
     * @param minimumPoolTokenAmount Minimum amount of pool tokens to mint
     */
    depositSingleTokenTypeExactAmountIn(userAccount: PublicKey, poolAccount: PublicKey, sourceMint: PublicKey, sourceTokenProgramId: PublicKey, userTransferAuthority: Keypair, sourceTokenAmount: bigint, minimumPoolTokenAmount: bigint, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
    static depositSingleTokenTypeExactAmountInInstruction(tokenSwap: PublicKey, authority: PublicKey, userTransferAuthority: PublicKey, source: PublicKey, intoA: PublicKey, intoB: PublicKey, poolToken: PublicKey, poolAccount: PublicKey, sourceMint: PublicKey, swapProgramId: PublicKey, sourceTokenProgramId: PublicKey, poolTokenProgramId: PublicKey, sourceTokenAmount: bigint, minimumPoolTokenAmount: bigint): TransactionInstruction;
    /**
     * Withdraw tokens from the pool
     *
     * @param userAccount User account to receive token A or B
     * @param poolAccount User account to burn pool token
     * @param destinationMint Mint for the destination token
     * @param destinationTokenProgramId Program id for the destination token
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param destinationTokenAmount The amount of token A or B to withdraw
     * @param maximumPoolTokenAmount Maximum amount of pool tokens to burn
     */
    withdrawSingleTokenTypeExactAmountOut(userAccount: PublicKey, poolAccount: PublicKey, destinationMint: PublicKey, destinationTokenProgramId: PublicKey, userTransferAuthority: Keypair, destinationTokenAmount: bigint, maximumPoolTokenAmount: bigint, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
    static withdrawSingleTokenTypeExactAmountOutInstruction(tokenSwap: PublicKey, authority: PublicKey, userTransferAuthority: PublicKey, poolMint: PublicKey, feeAccount: PublicKey, sourcePoolAccount: PublicKey, fromA: PublicKey, fromB: PublicKey, userAccount: PublicKey, destinationMint: PublicKey, swapProgramId: PublicKey, poolTokenProgramId: PublicKey, destinationTokenProgramId: PublicKey, destinationTokenAmount: bigint, maximumPoolTokenAmount: bigint): TransactionInstruction;
}
//# sourceMappingURL=index.d.ts.map