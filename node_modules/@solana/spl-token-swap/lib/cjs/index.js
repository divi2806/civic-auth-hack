"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSwap = exports.CurveType = exports.TokenSwapLayout = exports.OLD_TOKEN_SWAP_PROGRAM_ID = exports.TOKEN_SWAP_PROGRAM_ID = void 0;
const buffer_1 = require("buffer");
const buffer_layout_1 = require("@solana/buffer-layout");
const web3_js_1 = require("@solana/web3.js");
const buffer_layout_utils_1 = require("@solana/buffer-layout-utils");
const account_js_1 = require("./util/account.js");
exports.TOKEN_SWAP_PROGRAM_ID = new web3_js_1.PublicKey('SwapsVeCiPHMUAtzQWZw7RjsKjgCjhwU55QGu4U1Szw');
exports.OLD_TOKEN_SWAP_PROGRAM_ID = new web3_js_1.PublicKey('SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8');
exports.TokenSwapLayout = (0, buffer_layout_1.struct)([
    (0, buffer_layout_1.u8)('version'),
    (0, buffer_layout_1.u8)('isInitialized'),
    (0, buffer_layout_1.u8)('bumpSeed'),
    (0, buffer_layout_utils_1.publicKey)('poolTokenProgramId'),
    (0, buffer_layout_utils_1.publicKey)('tokenAccountA'),
    (0, buffer_layout_utils_1.publicKey)('tokenAccountB'),
    (0, buffer_layout_utils_1.publicKey)('tokenPool'),
    (0, buffer_layout_utils_1.publicKey)('mintA'),
    (0, buffer_layout_utils_1.publicKey)('mintB'),
    (0, buffer_layout_utils_1.publicKey)('feeAccount'),
    (0, buffer_layout_utils_1.u64)('tradeFeeNumerator'),
    (0, buffer_layout_utils_1.u64)('tradeFeeDenominator'),
    (0, buffer_layout_utils_1.u64)('ownerTradeFeeNumerator'),
    (0, buffer_layout_utils_1.u64)('ownerTradeFeeDenominator'),
    (0, buffer_layout_utils_1.u64)('ownerWithdrawFeeNumerator'),
    (0, buffer_layout_utils_1.u64)('ownerWithdrawFeeDenominator'),
    (0, buffer_layout_utils_1.u64)('hostFeeNumerator'),
    (0, buffer_layout_utils_1.u64)('hostFeeDenominator'),
    (0, buffer_layout_1.u8)('curveType'),
    (0, buffer_layout_1.blob)(32, 'curveParameters'),
]);
exports.CurveType = Object.freeze({
    ConstantProduct: 0, // Constant product curve, Uniswap-style
    ConstantPrice: 1, // Constant price curve, always X amount of A token for 1 B token, where X is defined at init
    Offset: 2, // Offset curve, like Uniswap, but with an additional offset on the token B side
});
/**
 * A program to exchange tokens against a pool of liquidity
 */
class TokenSwap {
    /**
     * Create a Token object attached to the specific token
     *
     * @param connection The connection to use
     * @param tokenSwap The token swap account
     * @param swapProgramId The program ID of the token-swap program
     * @param poolTokenProgramId The program ID of the token program for the pool tokens
     * @param poolToken The pool token
     * @param authority The authority over the swap and accounts
     * @param tokenAccountA The token swap's Token A account
     * @param tokenAccountB The token swap's Token B account
     * @param mintA The mint of Token A
     * @param mintB The mint of Token B
     * @param tradeFeeNumerator The trade fee numerator
     * @param tradeFeeDenominator The trade fee denominator
     * @param ownerTradeFeeNumerator The owner trade fee numerator
     * @param ownerTradeFeeDenominator The owner trade fee denominator
     * @param ownerWithdrawFeeNumerator The owner withdraw fee numerator
     * @param ownerWithdrawFeeDenominator The owner withdraw fee denominator
     * @param hostFeeNumerator The host fee numerator
     * @param hostFeeDenominator The host fee denominator
     * @param curveType The curve type
     * @param payer Pays for the transaction
     */
    constructor(connection, tokenSwap, swapProgramId, poolTokenProgramId, poolToken, feeAccount, authority, tokenAccountA, tokenAccountB, mintA, mintB, tradeFeeNumerator, tradeFeeDenominator, ownerTradeFeeNumerator, ownerTradeFeeDenominator, ownerWithdrawFeeNumerator, ownerWithdrawFeeDenominator, hostFeeNumerator, hostFeeDenominator, curveType, payer) {
        this.connection = connection;
        this.tokenSwap = tokenSwap;
        this.swapProgramId = swapProgramId;
        this.poolTokenProgramId = poolTokenProgramId;
        this.poolToken = poolToken;
        this.feeAccount = feeAccount;
        this.authority = authority;
        this.tokenAccountA = tokenAccountA;
        this.tokenAccountB = tokenAccountB;
        this.mintA = mintA;
        this.mintB = mintB;
        this.tradeFeeNumerator = tradeFeeNumerator;
        this.tradeFeeDenominator = tradeFeeDenominator;
        this.ownerTradeFeeNumerator = ownerTradeFeeNumerator;
        this.ownerTradeFeeDenominator = ownerTradeFeeDenominator;
        this.ownerWithdrawFeeNumerator = ownerWithdrawFeeNumerator;
        this.ownerWithdrawFeeDenominator = ownerWithdrawFeeDenominator;
        this.hostFeeNumerator = hostFeeNumerator;
        this.hostFeeDenominator = hostFeeDenominator;
        this.curveType = curveType;
        this.payer = payer;
        this.connection = connection;
        this.tokenSwap = tokenSwap;
        this.swapProgramId = swapProgramId;
        this.poolTokenProgramId = poolTokenProgramId;
        this.poolToken = poolToken;
        this.feeAccount = feeAccount;
        this.authority = authority;
        this.tokenAccountA = tokenAccountA;
        this.tokenAccountB = tokenAccountB;
        this.mintA = mintA;
        this.mintB = mintB;
        this.tradeFeeNumerator = tradeFeeNumerator;
        this.tradeFeeDenominator = tradeFeeDenominator;
        this.ownerTradeFeeNumerator = ownerTradeFeeNumerator;
        this.ownerTradeFeeDenominator = ownerTradeFeeDenominator;
        this.ownerWithdrawFeeNumerator = ownerWithdrawFeeNumerator;
        this.ownerWithdrawFeeDenominator = ownerWithdrawFeeDenominator;
        this.hostFeeNumerator = hostFeeNumerator;
        this.hostFeeDenominator = hostFeeDenominator;
        this.curveType = curveType;
        this.payer = payer;
    }
    /**
     * Get the minimum balance for the token swap account to be rent exempt
     *
     * @return Number of lamports required
     */
    static getMinBalanceRentForExemptTokenSwap(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield connection.getMinimumBalanceForRentExemption(exports.TokenSwapLayout.span);
        });
    }
    static createInitSwapInstruction(tokenSwapAccount, authority, tokenAccountA, tokenAccountB, tokenPool, feeAccount, tokenAccountPool, poolTokenProgramId, swapProgramId, tradeFeeNumerator, tradeFeeDenominator, ownerTradeFeeNumerator, ownerTradeFeeDenominator, ownerWithdrawFeeNumerator, ownerWithdrawFeeDenominator, hostFeeNumerator, hostFeeDenominator, curveType, curveParameters = new Uint8Array()) {
        const keys = [
            { pubkey: tokenSwapAccount.publicKey, isSigner: false, isWritable: true },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: tokenAccountA, isSigner: false, isWritable: false },
            { pubkey: tokenAccountB, isSigner: false, isWritable: false },
            { pubkey: tokenPool, isSigner: false, isWritable: true },
            { pubkey: feeAccount, isSigner: false, isWritable: false },
            { pubkey: tokenAccountPool, isSigner: false, isWritable: true },
            { pubkey: poolTokenProgramId, isSigner: false, isWritable: false },
        ];
        const commandDataLayout = (0, buffer_layout_1.struct)([
            (0, buffer_layout_1.u8)('instruction'),
            (0, buffer_layout_utils_1.u64)('tradeFeeNumerator'),
            (0, buffer_layout_utils_1.u64)('tradeFeeDenominator'),
            (0, buffer_layout_utils_1.u64)('ownerTradeFeeNumerator'),
            (0, buffer_layout_utils_1.u64)('ownerTradeFeeDenominator'),
            (0, buffer_layout_utils_1.u64)('ownerWithdrawFeeNumerator'),
            (0, buffer_layout_utils_1.u64)('ownerWithdrawFeeDenominator'),
            (0, buffer_layout_utils_1.u64)('hostFeeNumerator'),
            (0, buffer_layout_utils_1.u64)('hostFeeDenominator'),
            (0, buffer_layout_1.u8)('curveType'),
            (0, buffer_layout_1.blob)(32, 'curveParameters'),
        ]);
        let data = buffer_1.Buffer.alloc(1024);
        // package curve parameters
        // NOTE: currently assume all curves take a single parameter, u64 int
        //       the remaining 24 of the 32 bytes available are filled with 0s
        const curveParamsBuffer = buffer_1.Buffer.alloc(32);
        buffer_1.Buffer.from(curveParameters).copy(curveParamsBuffer);
        {
            const encodeLength = commandDataLayout.encode({
                instruction: 0, // InitializeSwap instruction
                tradeFeeNumerator,
                tradeFeeDenominator,
                ownerTradeFeeNumerator,
                ownerTradeFeeDenominator,
                ownerWithdrawFeeNumerator,
                ownerWithdrawFeeDenominator,
                hostFeeNumerator,
                hostFeeDenominator,
                curveType,
                curveParameters: curveParamsBuffer,
            }, data);
            data = data.slice(0, encodeLength);
        }
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: swapProgramId,
            data,
        });
    }
    static loadTokenSwap(connection, address, programId, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield (0, account_js_1.loadAccount)(connection, address, programId);
            const tokenSwapData = exports.TokenSwapLayout.decode(data);
            if (!tokenSwapData.isInitialized) {
                throw new Error(`Invalid token swap state`);
            }
            const [authority] = yield web3_js_1.PublicKey.findProgramAddress([address.toBuffer()], programId);
            const poolToken = new web3_js_1.PublicKey(tokenSwapData.tokenPool);
            const feeAccount = new web3_js_1.PublicKey(tokenSwapData.feeAccount);
            const tokenAccountA = new web3_js_1.PublicKey(tokenSwapData.tokenAccountA);
            const tokenAccountB = new web3_js_1.PublicKey(tokenSwapData.tokenAccountB);
            const mintA = new web3_js_1.PublicKey(tokenSwapData.mintA);
            const mintB = new web3_js_1.PublicKey(tokenSwapData.mintB);
            const poolTokenProgramId = new web3_js_1.PublicKey(tokenSwapData.poolTokenProgramId);
            const curveType = tokenSwapData.curveType;
            return new TokenSwap(connection, address, programId, poolTokenProgramId, poolToken, feeAccount, authority, tokenAccountA, tokenAccountB, mintA, mintB, tokenSwapData.tradeFeeNumerator, tokenSwapData.tradeFeeDenominator, tokenSwapData.ownerTradeFeeNumerator, tokenSwapData.ownerTradeFeeDenominator, tokenSwapData.ownerWithdrawFeeNumerator, tokenSwapData.ownerWithdrawFeeDenominator, tokenSwapData.hostFeeNumerator, tokenSwapData.hostFeeDenominator, curveType, payer);
        });
    }
    /**
     * Create a new Token Swap
     *
     * @param connection The connection to use
     * @param payer Pays for the transaction
     * @param tokenSwapAccount The token swap account
     * @param authority The authority over the swap and accounts
     * @param tokenAccountA: The token swap's Token A account
     * @param tokenAccountB: The token swap's Token B account
     * @param poolToken The pool token
     * @param tokenAccountPool The token swap's pool token account
     * @param poolTokenProgramId The program ID of the token program for pool tokens
     * @param swapProgramId The program ID of the token-swap program
     * @param feeNumerator Numerator of the fee ratio
     * @param feeDenominator Denominator of the fee ratio
     * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens
     */
    static createTokenSwap(connection, payer, tokenSwapAccount, authority, tokenAccountA, tokenAccountB, poolToken, mintA, mintB, feeAccount, tokenAccountPool, swapProgramId, poolTokenProgramId, tradeFeeNumerator, tradeFeeDenominator, ownerTradeFeeNumerator, ownerTradeFeeDenominator, ownerWithdrawFeeNumerator, ownerWithdrawFeeDenominator, hostFeeNumerator, hostFeeDenominator, curveType, curveParameters, confirmOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenSwap = new TokenSwap(connection, tokenSwapAccount.publicKey, swapProgramId, poolTokenProgramId, poolToken, feeAccount, authority, tokenAccountA, tokenAccountB, mintA, mintB, tradeFeeNumerator, tradeFeeDenominator, ownerTradeFeeNumerator, ownerTradeFeeDenominator, ownerWithdrawFeeNumerator, ownerWithdrawFeeDenominator, hostFeeNumerator, hostFeeDenominator, curveType, payer);
            // Allocate memory for the account
            const balanceNeeded = yield TokenSwap.getMinBalanceRentForExemptTokenSwap(connection);
            const transaction = new web3_js_1.Transaction();
            transaction.add(web3_js_1.SystemProgram.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: tokenSwapAccount.publicKey,
                lamports: balanceNeeded,
                space: exports.TokenSwapLayout.span,
                programId: swapProgramId,
            }));
            const instruction = TokenSwap.createInitSwapInstruction(tokenSwapAccount, authority, tokenAccountA, tokenAccountB, poolToken, feeAccount, tokenAccountPool, poolTokenProgramId, swapProgramId, tradeFeeNumerator, tradeFeeDenominator, ownerTradeFeeNumerator, ownerTradeFeeDenominator, ownerWithdrawFeeNumerator, ownerWithdrawFeeDenominator, hostFeeNumerator, hostFeeDenominator, curveType, curveParameters);
            transaction.add(instruction);
            yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, tokenSwapAccount], confirmOptions);
            return tokenSwap;
        });
    }
    /**
     * Swap token A for token B
     *
     * @param userSource User's source token account
     * @param poolSource Pool's source token account
     * @param poolDestination Pool's destination token account
     * @param userDestination User's destination token account
     * @param sourceMint Mint for the source token
     * @param destinationMint Mint for the destination token
     * @param sourceTokenProgramId Program id for the source token
     * @param destinationTokenProgramId Program id for the destination token
     * @param hostFeeAccount Host account to gather fees
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param amountIn Amount to transfer from source account
     * @param minimumAmountOut Minimum amount of tokens the user will receive
     */
    swap(userSource, poolSource, poolDestination, userDestination, sourceMint, destinationMint, sourceTokenProgramId, destinationTokenProgramId, hostFeeAccount, userTransferAuthority, amountIn, minimumAmountOut, confirmOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, web3_js_1.sendAndConfirmTransaction)(this.connection, new web3_js_1.Transaction().add(TokenSwap.swapInstruction(this.tokenSwap, this.authority, userTransferAuthority.publicKey, userSource, poolSource, poolDestination, userDestination, this.poolToken, this.feeAccount, hostFeeAccount, sourceMint, destinationMint, this.swapProgramId, sourceTokenProgramId, destinationTokenProgramId, this.poolTokenProgramId, amountIn, minimumAmountOut)), [this.payer, userTransferAuthority], confirmOptions);
        });
    }
    static swapInstruction(tokenSwap, authority, userTransferAuthority, userSource, poolSource, poolDestination, userDestination, poolMint, feeAccount, hostFeeAccount, sourceMint, destinationMint, swapProgramId, sourceTokenProgramId, destinationTokenProgramId, poolTokenProgramId, amountIn, minimumAmountOut) {
        const dataLayout = (0, buffer_layout_1.struct)([
            (0, buffer_layout_1.u8)('instruction'),
            (0, buffer_layout_utils_1.u64)('amountIn'),
            (0, buffer_layout_utils_1.u64)('minimumAmountOut'),
        ]);
        const data = buffer_1.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
            instruction: 1, // Swap instruction
            amountIn,
            minimumAmountOut,
        }, data);
        const keys = [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userTransferAuthority, isSigner: true, isWritable: false },
            { pubkey: userSource, isSigner: false, isWritable: true },
            { pubkey: poolSource, isSigner: false, isWritable: true },
            { pubkey: poolDestination, isSigner: false, isWritable: true },
            { pubkey: userDestination, isSigner: false, isWritable: true },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: feeAccount, isSigner: false, isWritable: true },
            { pubkey: sourceMint, isSigner: false, isWritable: false },
            { pubkey: destinationMint, isSigner: false, isWritable: false },
            { pubkey: sourceTokenProgramId, isSigner: false, isWritable: false },
            { pubkey: destinationTokenProgramId, isSigner: false, isWritable: false },
            { pubkey: poolTokenProgramId, isSigner: false, isWritable: false },
        ];
        if (hostFeeAccount !== null) {
            keys.push({ pubkey: hostFeeAccount, isSigner: false, isWritable: true });
        }
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: swapProgramId,
            data,
        });
    }
    /**
     * Deposit tokens into the pool
     * @param userAccountA User account for token A
     * @param userAccountB User account for token B
     * @param poolAccount User account for pool token
     * @param tokenProgramIdA Program id for token A
     * @param tokenProgramIdB Program id for token B
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param poolTokenAmount Amount of pool tokens to mint
     * @param maximumTokenA The maximum amount of token A to deposit
     * @param maximumTokenB The maximum amount of token B to deposit
     */
    depositAllTokenTypes(userAccountA, userAccountB, poolAccount, tokenProgramIdA, tokenProgramIdB, userTransferAuthority, poolTokenAmount, maximumTokenA, maximumTokenB, confirmOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, web3_js_1.sendAndConfirmTransaction)(this.connection, new web3_js_1.Transaction().add(TokenSwap.depositAllTokenTypesInstruction(this.tokenSwap, this.authority, userTransferAuthority.publicKey, userAccountA, userAccountB, this.tokenAccountA, this.tokenAccountB, this.poolToken, poolAccount, this.mintA, this.mintB, this.swapProgramId, tokenProgramIdA, tokenProgramIdB, this.poolTokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB)), [this.payer, userTransferAuthority], confirmOptions);
        });
    }
    static depositAllTokenTypesInstruction(tokenSwap, authority, userTransferAuthority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, mintA, mintB, swapProgramId, tokenProgramIdA, tokenProgramIdB, poolTokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {
        const dataLayout = (0, buffer_layout_1.struct)([
            (0, buffer_layout_1.u8)('instruction'),
            (0, buffer_layout_utils_1.u64)('poolTokenAmount'),
            (0, buffer_layout_utils_1.u64)('maximumTokenA'),
            (0, buffer_layout_utils_1.u64)('maximumTokenB'),
        ]);
        const data = buffer_1.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
            instruction: 2, // Deposit instruction
            poolTokenAmount,
            maximumTokenA,
            maximumTokenB,
        }, data);
        const keys = [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userTransferAuthority, isSigner: true, isWritable: false },
            { pubkey: sourceA, isSigner: false, isWritable: true },
            { pubkey: sourceB, isSigner: false, isWritable: true },
            { pubkey: intoA, isSigner: false, isWritable: true },
            { pubkey: intoB, isSigner: false, isWritable: true },
            { pubkey: poolToken, isSigner: false, isWritable: true },
            { pubkey: poolAccount, isSigner: false, isWritable: true },
            { pubkey: mintA, isSigner: false, isWritable: false },
            { pubkey: mintB, isSigner: false, isWritable: false },
            { pubkey: tokenProgramIdA, isSigner: false, isWritable: false },
            { pubkey: tokenProgramIdB, isSigner: false, isWritable: false },
            { pubkey: poolTokenProgramId, isSigner: false, isWritable: false },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: swapProgramId,
            data,
        });
    }
    /**
     * Withdraw tokens from the pool
     *
     * @param userAccountA User account for token A
     * @param userAccountB User account for token B
     * @param poolAccount User account for pool token
     * @param tokenProgramIdA Program id for token A
     * @param tokenProgramIdB Program id for token B
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param poolTokenAmount Amount of pool tokens to burn
     * @param minimumTokenA The minimum amount of token A to withdraw
     * @param minimumTokenB The minimum amount of token B to withdraw
     */
    withdrawAllTokenTypes(userAccountA, userAccountB, poolAccount, tokenProgramIdA, tokenProgramIdB, userTransferAuthority, poolTokenAmount, minimumTokenA, minimumTokenB, confirmOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, web3_js_1.sendAndConfirmTransaction)(this.connection, new web3_js_1.Transaction().add(TokenSwap.withdrawAllTokenTypesInstruction(this.tokenSwap, this.authority, userTransferAuthority.publicKey, this.poolToken, this.feeAccount, poolAccount, this.tokenAccountA, this.tokenAccountB, userAccountA, userAccountB, this.mintA, this.mintB, this.swapProgramId, this.poolTokenProgramId, tokenProgramIdA, tokenProgramIdB, poolTokenAmount, minimumTokenA, minimumTokenB)), [this.payer, userTransferAuthority], confirmOptions);
        });
    }
    static withdrawAllTokenTypesInstruction(tokenSwap, authority, userTransferAuthority, poolMint, feeAccount, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, mintA, mintB, swapProgramId, poolTokenProgramId, tokenProgramIdA, tokenProgramIdB, poolTokenAmount, minimumTokenA, minimumTokenB) {
        const dataLayout = (0, buffer_layout_1.struct)([
            (0, buffer_layout_1.u8)('instruction'),
            (0, buffer_layout_utils_1.u64)('poolTokenAmount'),
            (0, buffer_layout_utils_1.u64)('minimumTokenA'),
            (0, buffer_layout_utils_1.u64)('minimumTokenB'),
        ]);
        const data = buffer_1.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
            instruction: 3, // Withdraw instruction
            poolTokenAmount,
            minimumTokenA,
            minimumTokenB,
        }, data);
        const keys = [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userTransferAuthority, isSigner: true, isWritable: false },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: sourcePoolAccount, isSigner: false, isWritable: true },
            { pubkey: fromA, isSigner: false, isWritable: true },
            { pubkey: fromB, isSigner: false, isWritable: true },
            { pubkey: userAccountA, isSigner: false, isWritable: true },
            { pubkey: userAccountB, isSigner: false, isWritable: true },
            { pubkey: feeAccount, isSigner: false, isWritable: true },
            { pubkey: mintA, isSigner: false, isWritable: false },
            { pubkey: mintB, isSigner: false, isWritable: false },
            { pubkey: poolTokenProgramId, isSigner: false, isWritable: false },
            { pubkey: tokenProgramIdA, isSigner: false, isWritable: false },
            { pubkey: tokenProgramIdB, isSigner: false, isWritable: false },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: swapProgramId,
            data,
        });
    }
    /**
     * Deposit one side of tokens into the pool
     * @param userAccount User account to deposit token A or B
     * @param poolAccount User account to receive pool tokens
     * @param sourceMint Mint for the source token
     * @param sourceTokenProgramId Program id for the source token
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param sourceTokenAmount The amount of token A or B to deposit
     * @param minimumPoolTokenAmount Minimum amount of pool tokens to mint
     */
    depositSingleTokenTypeExactAmountIn(userAccount, poolAccount, sourceMint, sourceTokenProgramId, userTransferAuthority, sourceTokenAmount, minimumPoolTokenAmount, confirmOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, web3_js_1.sendAndConfirmTransaction)(this.connection, new web3_js_1.Transaction().add(TokenSwap.depositSingleTokenTypeExactAmountInInstruction(this.tokenSwap, this.authority, userTransferAuthority.publicKey, userAccount, this.tokenAccountA, this.tokenAccountB, this.poolToken, poolAccount, sourceMint, this.swapProgramId, sourceTokenProgramId, this.poolTokenProgramId, sourceTokenAmount, minimumPoolTokenAmount)), [this.payer, userTransferAuthority], confirmOptions);
        });
    }
    static depositSingleTokenTypeExactAmountInInstruction(tokenSwap, authority, userTransferAuthority, source, intoA, intoB, poolToken, poolAccount, sourceMint, swapProgramId, sourceTokenProgramId, poolTokenProgramId, sourceTokenAmount, minimumPoolTokenAmount) {
        const dataLayout = (0, buffer_layout_1.struct)([
            (0, buffer_layout_1.u8)('instruction'),
            (0, buffer_layout_utils_1.u64)('sourceTokenAmount'),
            (0, buffer_layout_utils_1.u64)('minimumPoolTokenAmount'),
        ]);
        const data = buffer_1.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
            instruction: 4, // depositSingleTokenTypeExactAmountIn instruction
            sourceTokenAmount,
            minimumPoolTokenAmount,
        }, data);
        const keys = [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userTransferAuthority, isSigner: true, isWritable: false },
            { pubkey: source, isSigner: false, isWritable: true },
            { pubkey: intoA, isSigner: false, isWritable: true },
            { pubkey: intoB, isSigner: false, isWritable: true },
            { pubkey: poolToken, isSigner: false, isWritable: true },
            { pubkey: poolAccount, isSigner: false, isWritable: true },
            { pubkey: sourceMint, isSigner: false, isWritable: false },
            { pubkey: sourceTokenProgramId, isSigner: false, isWritable: false },
            { pubkey: poolTokenProgramId, isSigner: false, isWritable: false },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: swapProgramId,
            data,
        });
    }
    /**
     * Withdraw tokens from the pool
     *
     * @param userAccount User account to receive token A or B
     * @param poolAccount User account to burn pool token
     * @param destinationMint Mint for the destination token
     * @param destinationTokenProgramId Program id for the destination token
     * @param userTransferAuthority Account delegated to transfer user's tokens
     * @param destinationTokenAmount The amount of token A or B to withdraw
     * @param maximumPoolTokenAmount Maximum amount of pool tokens to burn
     */
    withdrawSingleTokenTypeExactAmountOut(userAccount, poolAccount, destinationMint, destinationTokenProgramId, userTransferAuthority, destinationTokenAmount, maximumPoolTokenAmount, confirmOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, web3_js_1.sendAndConfirmTransaction)(this.connection, new web3_js_1.Transaction().add(TokenSwap.withdrawSingleTokenTypeExactAmountOutInstruction(this.tokenSwap, this.authority, userTransferAuthority.publicKey, this.poolToken, this.feeAccount, poolAccount, this.tokenAccountA, this.tokenAccountB, userAccount, destinationMint, this.swapProgramId, this.poolTokenProgramId, destinationTokenProgramId, destinationTokenAmount, maximumPoolTokenAmount)), [this.payer, userTransferAuthority], confirmOptions);
        });
    }
    static withdrawSingleTokenTypeExactAmountOutInstruction(tokenSwap, authority, userTransferAuthority, poolMint, feeAccount, sourcePoolAccount, fromA, fromB, userAccount, destinationMint, swapProgramId, poolTokenProgramId, destinationTokenProgramId, destinationTokenAmount, maximumPoolTokenAmount) {
        const dataLayout = (0, buffer_layout_1.struct)([
            (0, buffer_layout_1.u8)('instruction'),
            (0, buffer_layout_utils_1.u64)('destinationTokenAmount'),
            (0, buffer_layout_utils_1.u64)('maximumPoolTokenAmount'),
        ]);
        const data = buffer_1.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
            instruction: 5, // withdrawSingleTokenTypeExactAmountOut instruction
            destinationTokenAmount,
            maximumPoolTokenAmount,
        }, data);
        const keys = [
            { pubkey: tokenSwap, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userTransferAuthority, isSigner: true, isWritable: false },
            { pubkey: poolMint, isSigner: false, isWritable: true },
            { pubkey: sourcePoolAccount, isSigner: false, isWritable: true },
            { pubkey: fromA, isSigner: false, isWritable: true },
            { pubkey: fromB, isSigner: false, isWritable: true },
            { pubkey: userAccount, isSigner: false, isWritable: true },
            { pubkey: feeAccount, isSigner: false, isWritable: true },
            { pubkey: destinationMint, isSigner: false, isWritable: false },
            { pubkey: poolTokenProgramId, isSigner: false, isWritable: false },
            { pubkey: destinationTokenProgramId, isSigner: false, isWritable: false },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: swapProgramId,
            data,
        });
    }
}
exports.TokenSwap = TokenSwap;
//# sourceMappingURL=index.js.map