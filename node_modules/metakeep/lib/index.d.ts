/** @public */
export declare interface Description {
    text: string;
    image?: string;
}

/**
 * EthereumProvider
 * @public
 */
export declare class EthereumProvider {
    /**
     * RPC node URL for the connected network
     * @readonly
     */
    rpcNodeUrl: string;
    /**
     * Connection status of the provider
     * This is true if the provider is connected to the user's wallet and has a
     * valid connection to the RPC node.
     * @defaultValue false
     * @readonly
     */
    connected: boolean;
    /**
     * Array of connected user's accounts
     * @defaultValue []
     * @readonly
     */
    accounts: string[];
    /**
     * Chain ID of connected network
     * @defaultValue 137
     * @readonly
     */
    chainId: number;
    /**
     * Map of chainId to RPC node URL
     * @defaultValue Map()
     * @readonly
     * */
    rpcNodeUrls: {
        [key: number]: string;
    };









    /**
     * Makes a request to the Ethereum provider
     * @param payload - Request payload
     * @returns Promise that resolves to the response from the provider
     */
    request(payload: RequestPayload): Promise<any>;









    /**
     * Connects the provider to the user's wallet.
     * This method should be called before making any requests to the provider.
     *
     * @returns Promise that resolves to the user's accounts
     */
    enable(): Promise<string[]>;
}

/**
 * MetaKeep SDK
 * @public
 */
export declare class MetaKeep {


    /**
     * Map of chainId to RPC node URL
     * @defaultValue Map()
     * @readonly
     */
    rpcNodeUrls: {
        [key: number]: string;
    };
    /**
     * Chain ID of the network
     * @defaultValue 137
     * @readonly
     */
    chainId: number;
    /**
     * App ID
     * @readonly
     */
    appId: string;

    /**
     * MetaKeep SDK
     */
    constructor(options: {
        appId: string;
        environment?: string;
        user?: any;
        chainId?: number;
        rpcNodeUrls?: {
            [key: number]: string;
        };

    });
    /**
     * EthereumProvider
     * @returns Promise that resolves to the EthereumProvider
     */
    get ethereum(): Promise<EthereumProvider>;


    /**
     * Get consent from the user
     * @param consentToken - Consent token
     * @returns Promise that resolves to the consent object
     */
    getConsent: (consentToken: string) => Promise<any>;
    /**
     * Sign a message
     * @param message - Message to sign
     * @param reason - Reason for signing the message
     * @returns Promise that resolves to the signed message
     */
    signMessage: (message: string, reason: string) => Promise<any>;
    /**
     * Sign a transaction
     * @param transactionObject - Transaction object
     * @param reason - Reason for signing the transaction
     * @returns Promise that resolves to the signed transaction
     */
    signTransaction: (transactionObject: any, reason: string) => Promise<any>;
    /**
     * Sign multiple transactions
     * @param transactionObjects - Array of transaction objects with reason for each transaction
     * @param reason - Reason for signing the transactions
     * @returns Promise that resolves to the signed transactions
     */
    signTransactionMultiple: (transactionObjects: TransactionObjectWithReason[], reason: string) => Promise<any>;
    /**
     * Sign typed data
     * @param typedData - Typed data
     * @param reason - Reason for signing the typed data
     * @returns Promise that resolves to the signed typed data
     */
    signTypedData: (typedData: any, reason: string) => Promise<any>;

    /**
     * Get user wallet
     * @returns Promise that resolves to the user wallet
     */
    getWallet: () => Promise<any>;
    /**
     * Decrypt encrypted data
     * @param encryptedData - The encrypted data to be decrypted
     * @param description - The description of the decryption request
     * @throws If the encrypted data or description text is not provided
     * @returns Promise that resolves to the decrypted data
     */
    decrypt: ({ encryptedData, description, }: {
        encryptedData: string;
        description: Description;
    }) => Promise<{
        data?: ArrayBuffer;
        status: string;
    }>;

}

/** Request payload for making requests to the Ethereum provider
 * @public
 * */
export declare interface RequestPayload {
    method: string;
    params: any[];
}

/**
 * Transaction object with reason for signing the transaction
 * @public
 */
export declare interface TransactionObjectWithReason {
    transactionObject: any;
    reason: string;
}

export { }
